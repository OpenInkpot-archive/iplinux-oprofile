#!/bin/sh
# -*- TCL -*-
# the next line restarts using wish \
exec wish "$0" "$@"

# This is my first tcl/tk app so in many case I have write dirty thing to work around my
# poor knowledge of tcl/tk. I need feed back from a tcl/tk wizard on many thing in this file.

# The only place where I make some supposition on the number of counter is
# inside the gui creation ( proc setup_event_frame )

# global var

# The maximum number of counter. Would be a parameter read at run time or a configure
# time option
set max_counter_number 2

# To manipulate the global var needed by each counter.
set counter_setup_var { event_type counter unit_mask usr_count kernel_count }

#  This list is here to avoid maintaining separate list for each processor
# type / counter number. It is the main data structure which describe all
# counter event. When adding new processor/event/counter only this data
# structure need update (adding counter require also work in the code).

# TODO : this must be shared in some way with op_events.c

# list entry item :
# 1 event type/name
# 2 bit mask 
#  1 : avail for PPro
#  2 : avail for P2
#  4 : avail for P3
#  8 : avail for P4  currently not supported.
# 3 bit mask
#  1 : available for counter 0
#  2 : available for counter 1
#  4 : and so on...
# 4 help string displayed in the status bar.
# 5 minimum counter value.
# optional args follow :
# 6 a string in { mandatory bit_mask exclusive }
#  mandatory entry are event that need this particular value for this event
#  bit_mask means the different value can be or'ed
#  exclusive means than only one of the value can be passed to the profiler.
# 7 the default value
# 8 a list of  : { unit_bit_mask_or_value string }+
set event_type_list {
    { DISABLED -1 -1 "Select it to disable this counter" 0 }
    { CPU_CLK_UNHALTED 7 3 "Clock processor not halted" 6000 }
    { DATA_MEM_REFS 7 3 "All memory reference, cachable and non" 500 }
    { DCU_LINES_IN  7 3 "Total line allocated in DCU" 500 }
    { DCU_M_LINES_IN  7 3 "Number of M state lines allocated in DCU" 500 }
    { DCU_M_LINES_OUT  7 3 "Number of M lines evicted from the DCU" 500 }
    { DCU_MISS_OUTSTANDING 7 3 "Number of cycles while DCU miss outstanding" 500 }
    { IFU_IFETCH 7 3 "Number of non/cachable instruction fetches" 500 }
    { IFU_IFETCH_MISS 7 3 "Number of instruction fetch misses" 500 }
    { ITLB_MISS 7 3 "Number of ITLB misses" 500 }
    { IFU_MEM_STALL 7 3 "Cycles instruction fetch pipe is stalled" 500 }
    { ILD_STALL 7 3 "Cycles instruction length decoder is stalled" 500 }
    { L2_IFETCH 7 3 "Number of L2 instruction fetches" 500
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	} 
    }
    { L2_LD 7 3 "Number of L2 data load" 500
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	} 
    }
    { L2_ST 7 3 "Number of L2 data stores" 500
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	}
    }
    { L2_LINES_IN 7 3 "Number of allocated lines in L2" 500 }
    { L2_LINES_OUT 7 3 "Number of recovered lines from L2" 500 }
    { L2_M_LINES_INM 7 3 "Number of modified lines allocated in L2" 500 }
    { L2_M_LINES_OUTM 7 3 "Number of modified lines removed from L2" 500 }
    { L2_RQSTS 7 3 "Number of L2 requests" 500
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	}
    }
    { L2_ADS 7 3 "Number of L2 address strobes" 500 }
    { L2_DBUS_BUSY 7 3 "Number of cycles data bus was busy" 500 }
    { L2_DMUS_BUSY_RD 7 3 "Cycles data bus was busy in xfer from L2 to cpu" 500 }
    { BUS_DRDY_CLOCKS 7 3 "Number of clocks DRDY is asserted" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_LOCK_CLOCKS 7 3 "Number of clocks LOCK is asserted" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_REQ_OUTSTANDING 7 3 "Number of outstanding bus request" 500 }
    { BUS_TRAN_BRD 7 3 "Number of burst read transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_RFO 7 3 "Number of read for ownership transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_WB 7 3 "Number of write back transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_IFETCH 7 3 "Number of instruction fetch transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_INVAL 7 3 "Number of invalid transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_PWR 7 3 "Number of partial write transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_P 7 3 "Number of partial transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_IO 7 3 "Number of I/O transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_DEF 7 3 "Number of deferred transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}    
    }
    { BUS_TRAN_BURST 7 3 "Number of burst transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_ANY 7 3 "Number of all transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_MEM 7 3 "Number of memory transactions" 500
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_DATA_RCV 7 3 "Bus cycles this processor is receiving data" 500 }
    { BUS_BNR_DRV 7 3 "bus cycles this processor is driving BNR pin" 500 }
    { BUS_HIT_DRV 7 3 "bus cycles this processor is driving HIT pin" 500 }
    { BUS_HITM_DRV 7 3 "bus cycles this processor is driving HITM pin" 500 }
    { BUS_SNOOP_STALL 7 3 "cycles during bus snoop stall" 500 }
    { COMP_FLOP_RET 7 1
	  "Number of computational FP operations retired - Counter 0 only" 3000 }
    { FLOPS 7 1
	  "Number of computational FP operations executed - Counter 0 only" 3000 }
    { FP_ASSIST 7 2
	"Number of exceptions handled by microcode - Counter 1 only" 500 }
    { MUL 7 2 "Number of multiplies - Counter 1 only" 1000 }
    { DIV 7 2 "Number of divides - Counter 1 only" 500 }
    { CYCLES_DIV_BUSY 7 1 "Cycles divider is busy - Counter 0 only" 1000 }
    { LD_BLOCKS 7 3 "Number of store blocks" 500 }
    { SB_DRAINS 7 3 "Number of store buffer drain cycles" 500 }
    { MISALIGN_MEM_REF 7 3 "Number of misaligned data memory references" 500 }
    { EMON_KNI_PREF_DISPATCHED 4 3
	  "Number KNI pre-fetch/weakly ordered insns dispatch - P3 only" 500
	exclusive 0
	{ 
	    { 0 "Prefecth NTA" }
	    { 1 "Prefetch T1" }
	    { 2 "Prefetch T2" }
	    { 3 "weakly ordered stores" }
	} 
    }
    { EMON_KNI_PREF_MISS 4 3
      "Number KNI pre-fetch/weakly ordered insns that miss all cache - P3 only" 500
	exclusive 0
	{
	    { 0 "Prefecth NTA" }
	    { 1 "Prefetch T1" }
	    { 2 "Prefetch T2" }
	    { 3 "weakly ordered stores" }
	}
    }
    { INST_RETIRED 7 3 "Number of instructions retired" 6000 }
    { UOPS_RETIRED 7 3 "Number of UOPs retired" 6000 }
    { INST_DECODED 7 3 "Number of instructions decoded" 6000 }
    { EMON_KNI_INST_RETIRED 4 3 "Number of KNI instructions retired - P3 only" 3000
	exclusive 0
	{
	    { 0 "Packed and scalar" }
	    { 1 "Packed" }
	}
    }
    { EMON_KNI_COMP_INST_RET 4 3 
	"Number of KNI instructions computation retired - P3 only" 3000
	exclusive 0
	{ 
	    { 0 "Packed and scalar" }
	    { 1 "Packed" }
	} 
    }
    { HW_INT_RX 7 3 "Number of hardware interrupts received" 500 }
    { CYCLES_INT_MASKED 7 3 "Cycles interrupt are disabled" 500 }
    { CYCLES_INT_PENDING_AND_MASKED 7 3 
	"Cycles interrupts are disabled with pending interrupts" 500 }
    { BR_INST_RETIRED 7 3 "Number of branch instructions retired" 500 }
    { BR_MISS_PRED_RETIRED 7 3 "Number of mispredicted branches retired" 500 }
    { BR_TAKEN_RETIRED 7 3 "Number of taken branches retired" 500 }
    { BR_MISS_PRED_TAKEN_RET 7 3 
	"Number of taken mispredictions branches retired" 500 }
    { BR_INST_DECODED 7 3 "Number of branches instructions decoded" 500 }
    { BTB_MISSES 7 3 "Number of branches that miss the BTB" 500 }
    { BR_BOGUS 7 3 "Number of bogus branches" 500 }
    { BACLEARS 7 3 "Number of times BACLEAR is asserted" 500 }
    { RESOURCE_STALLS 7 3 "Cycles during resource related stalls" 500 }
    { PARTIAL_RAT_STALLS 7 3 "cycles or event for partial stalls" 500 }
    { SEGMENT_REG_LOADS 7 3 "Number of segment register loads" 500 }
    { MMX_INSTR_EXEC 2 3 "Number of MMX instructions executed - P2 only" 3000 }
    { MMX_SAT_INSTR_EXEC 6 3 
	"Number of MMX saturating instructions executed - P2/P3 only" 3000 }
    { MMX_UOPS_EXEC 6 3 "Number of MMX UOPs executed - P2/P3 only" 3000
	mandatory 15
	{
	    { 15 "Mandatory" }
	}
    }
    { MMX_INSTR_TYPE_EXEC 6 3 "Number of MMX packing instructions - P2/P3 only" 3000
	bit_mask 63
	{
	    { 1 "MMX packed multiplies" }
	    { 2 "MMX packed shifts" }
	    { 4 "MMX pack operations" }
	    { 8 "MMX unpack operations" }
	    { 16 "MMX packed logical" }
	    { 32 "MMX packed arithmetic" }
	    { 63 "MMX pack/unpack and all operations" }
	}
    }
    { FP_MMX_TRANS 6 3 "MMX-floating point transitions - P2/P3 only" 3000
	exclusive 0
	{
	    { 0 "Transitions from MMX to floating point" }
	    { 1 "Transitions from floating point to MMX" }
	}
    }
    { MMX_ASSIST 6 3 "Number of EMMS instructions executed - P2/P3 only" 500 }
    { MMX_INSTR_RET 2 3 "Number of MMX instructions retired - P2 only" 3000 }
    { SEG_RENAME_STALLS 6 3
	  "Number of segment register renaming stalls - P2/P3 only" 3000
	bit_mask 15
	{
	    { 1 "ES register" }
	    { 2 "DS register" }
	    { 4 "FS register" }
	    { 8 "GS register" }
	    { 15 "ES, DS, FS, GS register" }
	}
    }
    { SEG_REG_RENAMES 6 3  "Number of segment register renames - P2/P3 only" 3000
	bit_mask 15
	{
	    { 1 "ES register" }
	    { 2 "DS register" }
	    { 4 "FS register" }
	    { 8 "GS register" }
	    { 15 "ES, DS, FS, GS register" }
	}
    }
    { RET_SEG_RENAMES 6 3
	  "Number of segment register rename events retired - P2/P3 only" 3000 }
}

# This is defined in oprofile.h
set OP_MAX_PERF_COUNT 2147483647

#  This section contains the setting of default hard-coded value. They are
# use only if the ~./oprofile/gui_advanced_setup.defaults do not exist else
# this value are override by loading the configuration file.
# Must be coherent with op_start.

for { set i 0 } { $i < $max_counter_number } { incr i } {
    set event_type_$i "DISABLED"
    set counter_$i 0
    set unit_mask_$i -1
    set usr_count_$i 1
    set kernel_count_$i 1

    set old_event_type_$i ""
}

for { set i 0 } { $i < $max_counter_number } { incr i } {
    foreach j $event_type_list {
	# put min value * 100 as default value.
	set new_counter_[set i]([lindex $j 0]) [expr [lindex $j 4] * 100]
	set new_unit_mask_[set i]([lindex $j 0]) -1
	set new_usr_count_[set i]([lindex $j 0]) 1
	set new_kernel_count_[set i]([lindex $j 0]) 1
    }
}

set event_type_0 "CPU_CLK_UNHALTED"

# In some situation it is incorrect to get the System.map and kernel
# filename from here but this provide a correct default value in many case.
set build_dir /lib/modules/[exec uname -r]/build
set kernel_filename $build_dir/vmlinux
set map_filename $build_dir/System.map

set buffer_size 262144
set hash_size 65536
set kernel_only 0
set ignore_myself 0
set pid_filter 0
set pgrp_filter 0

set base_dir "/var/opd"
set samples_dir "samples"
set device_filename "opdev"
set hashmap_device_file "ophashmapdev"
set log_filename "oprofiled.log"

# end of hard-coded defaults value section

# utilities proc

proc get_counter { counter } {
    global event_type_$counter
    return new_counter_[set counter]([set event_type_$counter])
}

proc get_unit_mask { counter } {
    global event_type_$counter
    return new_unit_mask_[set counter]([set event_type_$counter])
}

proc get_usr_count { counter } {
    global event_type_$counter
    return new_usr_count_[set counter]([set event_type_$counter])
}

proc get_kernel_count { counter } {
    global event_type_$counter
    return new_kernel_count_[set counter]([set event_type_$counter])
}

# save the global counter setup to the global array(event_type) counter setup.
proc save_to_array { counter } {
    global new_counter_$counter
    global new_unit_mask_$counter
    global new_usr_count_$counter
    global new_kernel_count_$counter
    global counter_$counter
    global unit_mask_$counter
    global usr_count_$counter
    global kernel_count_$counter

    set [get_counter $counter] [set counter_$counter]
    set [get_unit_mask $counter] [set unit_mask_$counter]
    set [get_usr_count $counter] [set usr_count_$counter]
    set [get_kernel_count $counter] [set kernel_count_$counter]
}

# save the global array(event_type) counter setup to the global counter setup.
proc save_to_global { counter } {
    global new_counter_$counter
    global new_unit_mask_$counter
    global new_usr_count_$counter
    global new_kernel_count_$counter
    global counter_$counter
    global unit_mask_$counter
    global usr_count_$counter
    global kernel_count_$counter

    set counter_$counter [set [get_counter $counter]]
    set unit_mask_$counter [set [get_unit_mask $counter]]
    set usr_count_$counter [set [get_usr_count $counter]]
    set kernel_count_$counter [set [get_kernel_count $counter]]
}

proc str_eq { a b } {
    if { $a == $b } then {
	return 1
    } else {
	return 0
    }
}

# item_list: { name text }*
proc create_checkbutton_group { parent_name side width item_list } {

    foreach i $item_list {
	set button_name $parent_name[lindex $i 0]
	set button_text [lindex $i 1]
	checkbutton $button_name -text $button_text -width $width

	if { $side == "top" || $side == "bottom" } then {
	    pack $button_name -side $side -pady 2 -anchor w
	} else {
	    pack $button_name -side $side -pady 2
	}
    }
}

# create a simple text entry optionally read only.
proc create_text { parent_name name height read_only } {

    set name $parent_name$name

    if { $height <= 0 } then {
	set height [ llength $text ]
    }

    text $name -height $height

    if { $read_only != 0 } then {
	$name configure -state disabled
    }

    pack $name
}

# item_list: { name value text ["additional command"] }
proc create_radiobutton_group { parent_name var_name side item_list } {

    foreach i $item_list {

	set name $parent_name[lindex $i 0]

	radiobutton $name -text [lindex $i 2] -variable $var_name -value [lindex $i 1]

	if [ expr [ llength $i] >= 4 ] then {
	    uplevel $name configure [lrange [lindex $i 3] 0 end]
	}

	if { $side == "top" || $side == "bottom" } then {
	    pack $name -side $side -pady 2 -anchor w
	} else {
	    pack $name -side $side -pady 2
	}
    }
}

# Return the event entry list for event name hint else an empty list.
proc search_event { hint } {
    global event_type_list

    foreach i $event_type_list {
	if { [lindex $i 0] == $hint } then {
	    return $i
	}
    }
}

# Return 1 if the event named hint need a (non-mandatory) unit mask option, 
# else return 0.
proc need_unit_mask { hint } {
    set i [search_event $hint]

    if { [expr [ llength $i ] > 5] && [str_eq [lindex $i 5] mandatory] == 0 } then {
	return 1
    } else {
	return 0
    }
}

# return a list usable as the param item_list of create_radiobutton_group.
proc create_event_list { counter } {
    global processor_type
    global event_type_list

    set counter_mask [expr 1 << $counter ]
    set processor_mask [expr 1 << $processor_type]

    set j 1

    foreach i $event_type_list {
	# this work because [lindex $i 0] is a single word string
	set entry "rb$j [lindex $i 0] [lindex $i 0]"

	if { ! ( ( [ lindex $i 1 ] & $processor_mask) &&
	     ( [ lindex $i 2 ] & $counter_mask) )  } then {
	    lappend entry "-state disabled"
	}

	lappend entry "-command \"onRadiobuttonChange $counter\""

	lappend temp_list $entry
	incr j
    }

    return $temp_list;
}

# return 1 if the profiler is started else return 0
proc is_profiler_started {} {

    set ps_x [exec ps -x]
    if { [string first oprofiled $ps_x] != -1 } {
	return 1
    }

    return 0
}

# pre-condition : the counter is not disabled.
# return 1 if setup is ok or if user bypass the warning else return 0.
proc validate_counter_setup { counter event_type } {

    global usr_count_$counter kernel_count_$counter
    global OP_MAX_PERF_COUNT

    if { [set usr_count_$counter] == 0 && [set kernel_count_$counter] == 0 } then {
	tk_messageBox -message "You must enable at least one of the USR ring count/OS ring count for counter $counter"
	return 0
    }

    set list [search_event $event_type]

    set message [op_check_range counter_$counter [lindex $list 4] $OP_MAX_PERF_COUNT]
    if { [string length $message] != 0 } then {
	set answer [tk_messageBox -type yesno -message \
			"invalid parameter apply anyway ? :$message"]
	case $answer {
	    no { return 0 }
	}
    }

    # Some other validation needed here ?

    return 1
}

# Start the profiler.
proc onStartProfiling {} {
    global processor_type
    global kernel_filename map_filename
    global buffer_size hash_size
    global kernel_only ignore_myself
    global pid_filter pgrp_filter
    global base_dir samples_dir
    global device_filename hashmap_device_file log_filename

    if { [is_profiler_started] == 1 } {
	    set answer [tk_messageBox -type yesno -message \
			    "profiler is already started : stop and restart it ?"]
	    case $answer {
		no { return }
	    }
    }

    # This can be redundant some times and give twice time the warning message to 
    # the user. Keep it in this way because it is the correct way to encourage user to
    # correctly make the setup :)
    if { [validate_advanced_setup] != 0 } then {
	return
    }

    global max_counter_number

    # for now validation is made counter by counter, if requested it can be make
    # by accumulating error message and by showing only one error message.
    for { set i 0 } { $i < $max_counter_number } { incr i } {

	global event_type_$i

	if { [str_eq [set event_type_$i] DISABLED] == 0 } {

	    if { [validate_counter_setup $i [set event_type_$i]] == 0 } then {
		return
	    }
	}
    }

    set args ""

    global counter_setup_var

    for { set i 0 } { $i < $max_counter_number } { incr i } {

	if { [str_eq [set event_type_$i] DISABLED] == 0 } {
	    
	    foreach item $counter_setup_var {
		global [set item]_$i
	    }

	    append args " --ctr$i-event=[set event_type_$i]"
	    append args " --ctr$i-count=[set counter_$i]"
	    append args " --ctr$i-kernel=[set kernel_count_$i]"
	    append args " --ctr$i-user=[set usr_count_$i]"

	    # A value of -1 is used to mark than unit mask has not been set.
	    if { [need_unit_mask [set event_type_$i]] } then {

		set event [search_event [set event_type_$i]]

		set default_value [lindex $event 6]

		if { [set unit_mask_$i] == -1 } then {
		    set unit_mask_$i $default_value
		}
	    }

	    if { [set unit_mask_$i] != -1 } then {
		append args " --ctr$i-unit-mask=[set unit_mask_$i]"
	    }
	}
    }

    # If args is empty this means there is no counter enabled.
    if { [string length $args] == 0 } then {
 	tk_messageBox -message "you must enable at least one of the counter"
 	return
    }

    append args " --use-cpu=$processor_type"
    append args " --map-file=$map_filename"
    append args " --vmlinux=$kernel_filename"
    append args " --kernel-only=$kernel_only"
    append args " --pid-filter=$pid_filter"
    append args " --pgrp-filter=$pgrp_filter"
    append args " --base-dir=$base_dir"
    append args " --samples-dir=$base_dir/$samples_dir"
    append args " --device-file=$base_dir/$device_filename"
    append args " --hash-map-device-file=$base_dir/$hashmap_device_file"
    append args " --log-file=$base_dir/$log_filename"

    # "uplevel ..." is the right way in tcl/tk to separate arguments in an exec command.
    tk_messageBox -message "[uplevel exec op_start [lrange $args 0 end]]\n\
               or to use the Flush profile data button"
}

# Stop the profiling.
proc onStopProfiling {} {

    if { [is_profiler_started] == 1 } then {
	onFlushData
	tk_messageBox -message [exec op_stop]
    } else {
	tk_messageBox -message "profiler already stopped"
    }
}

# Flush the profiling data.
proc onFlushData {} {

    # the user can try to flush even if the driver is not loaded so check for
    # the file existence before attempting to make a flush.
    if { [file exists /proc/sys/dev/oprofile/dump] } then {
	exec op_dump
    }
}

# create the ~/.oprofile dir if it is not exist.
proc auto_create_config_directory {} {
    if { [file isdirectory ~/.oprofile] == 0 } then {
	file mkdir ~/.oprofile
    }
}

# copy filename.defaults to filename if filename does not exist.
proc copy_file_if_not_exist { filename } {

   if { [file exists ~/.oprofile/$filename] == 0 } then {
       set input [open ~/.oprofile/$filename.defaults r]
       set output [open ~/.oprofile/$filename w]

       fcopy $input $output

       close $input
       close $output
    }
}

# auto-create and save the advanced setup file.
proc save_advanced_setup { filename destroy_old_file } {
    auto_create_config_directory

    if { $destroy_old_file == 1 } then {
	file delete ~/.oprofile/$filename
    }

    if { [file exists ~/.oprofile/$filename] == 0 } then {
	set fd [open ~/.oprofile/$filename w]

	puts $fd "# Defaults advanced configuration of start profiler's gui"
	puts $fd "# You can comment this file, comment would not be lost"

	set var_list { kernel_filename map_filename buffer_size hash_size
	    pid_filter pgrp_filter base_dir samples_dir device_filename
	    hashmap_device_file log_filename kernel_only ignore_myself
	}

	foreach i $var_list {
	    global $i

	    puts $fd "$i=[set $i]"
	}

	close $fd
    }
}

# load all the stuff that can be found in the advanced setup form.
proc load_advanced_setup { filename } {

    save_advanced_setup gui_advanced_setup.defaults 0

    copy_file_if_not_exist $filename

    set fd [open ~/.oprofile/$filename r]

    while { [gets $fd temp] != -1 } {
	if { [string first "\#" $temp ] != 0 } then {
	    set list [split $temp "="]

	    set key [lindex $list 0]
	    set value [lindex $list 1]

	    global $key

	    set $key $value
	}
    }

    close $fd
}

# save the setup.
proc save_setup { filename destroy_old_file } {
    auto_create_config_directory

    if { $destroy_old_file == 1 } then {
	file delete ~/.oprofile/$filename
    }

    global max_counter_number

    for { set i 0 } { $i < $max_counter_number } { incr i } {
	save_to_array $i
    }

    if { [file exists ~/.oprofile/$filename] == 0 } then {
	set fd [open ~/.oprofile/$filename w]

	puts $fd "# Defaults configuration of start profiler's gui"
	puts $fd "# Do not add comment this file, comment will be lost"

	global max_counter_number
	global counter_setup_var

	for { set i 0 } { $i < $max_counter_number } { incr i } {
	    foreach item $counter_setup_var {
		global [set item]_$i

		puts $fd "[set item]_$i=[set [set item]_$i]"
	    }
	}

	for { set i 0 } { $i < $max_counter_number } { incr i } {

	    global event_type_list

	    foreach j $event_type_list {
		global new_counter_$i
		set temp new_counter_[set i]([lindex $j 0])
		puts $fd "$temp=[set $temp]"

		global new_unit_mask_$i
		set temp new_unit_mask_[set i]([lindex $j 0])
		puts $fd "$temp=[set $temp]"

		global new_usr_count_$i
		set temp new_usr_count_[set i]([lindex $j 0])
		puts $fd "$temp=[set $temp]"

		global new_kernel_count_$i
		set temp new_kernel_count_[set i]([lindex $j 0])
		puts $fd "$temp=[set $temp]"
	    }
	}


	close $fd
    }

    if { $destroy_old_file == 1 } then {
	save_advanced_setup gui_advanced_setup 1
    }
}

# load the setup and conditionally the advanced setup.
# force_advanced_setup_load :
# 0 : check than the user wants to reload from the defaults.
# 1 : unconditionally reload from the current setup
proc load_setup { filename force_advanced_setup_load } {
    save_setup gui_setup.defaults 0

    copy_file_if_not_exist gui_setup

    set fd [open ~/.oprofile/$filename r]

    while { [gets $fd temp] != -1 } {
	if { [string first "\#" $temp ] != 0 } then {
	    set list [split $temp "="]

	    set key [lindex $list 0]
	    set value [lindex $list 1]

	    # $key can be an array(index), so globalise only the array name
	    global [lindex [split $key "("] 0]

	    set $key $value
	}
    }

    close $fd

    if { $force_advanced_setup_load == 0 } then {
        case [tk_messageBox -type yesno -message "Load also the default advanced setup ?"] {
	    yes { set force_advanced_setup_load 2 }
	}
    }

    if { $force_advanced_setup_load >= 1 } then {

	if { $force_advanced_setup_load == 2 } then {
	    load_advanced_setup gui_advanced_setup.defaults
	} else {
	    load_advanced_setup gui_advanced_setup
	}
    }

    # this is needed to setup the gui from the new loaded value
    onRadiobuttonChange 0
    onRadiobuttonChange 1
}

# return an empty string if the range is ok.
# Note than allowed range is (min, max) and not (min, max( to be coherent with
# the op_check_range() macro in oprofile.h
proc op_check_range { value min max } {
    # $value can be an array(index), so globalise only the array name
    global [lindex [split $value "("] 0]

    # this is coherent with op_check_range() macro in oprofile.h
    if { [set $value] < $min || [set $value] > $max } then {
	return "\n\n$value is not in the allowed range ($min, $max) :\n[set $value]"
    }

    return ""
}

# return 
# 0 : ok, 
# 1 some problem occur but the user request to ignore it
# 2 some problem occur and the user request a cancel operation.
# For now I allow the user to try with really invalidate value.
proc validate_advanced_setup {} {
    global kernel_filename map_filename
    global buffer_size hash_size
    # TODO : some of this need validation. Perhaps warn if directory does
    # not exist to avoid some common pitfall ?
#    global kernel_only ignore_myself
#    global pid_filter pgrp_filter
#    global base_dir samples_dir
#    global device_filename hashmap_device_file log_filename

    set message ""

    if { [file isfile $kernel_filename] == 0 } then {
	append message "\n\nvmlinux does not exist :\n$kernel_filename"
    }

    if { [file isfile $map_filename] == 0 } then {
	append message "\n\nSystem.map does not exist :\n$map_filename"
    }

    append message "[op_check_range hash_size 256 262144]"
    append message "[op_check_range buffer_size 1024 1048576]"

    if { [string length $message] != 0 } then {
        set answer [tk_messageBox -type yesnocancel -message "these parameters are not correct apply anyway ? :$message"]
              case $answer {
                  yes { return 0 }
                  no { return 1 }
		  cancel { return 2 }
              }


    } else {
	return 0
    }
}

# when the form advanced setup is close by an ok we need to validate/save
# the new contents of this form in the global variable. We also need to save
# here the new settings to persistent storage.
proc onAdvancedSetupOK {} {

    # kernel_only and ignore_myself are omitted here, they are treated
    # separately in the code.
    set var_list { kernel_filename map_filename buffer_size hash_size
	pid_filter pgrp_filter base_dir samples_dir device_filename
	hashmap_device_file log_filename
    }

    global temp_kernel_only temp_ignore_myself kernel_only ignore_myself

    # save locally the change
    foreach i $var_list {
	global $i

	set temp_$i [set $i]

	set $i [.f_advanced_setup.$i get]
    }

    set temp_temp_kernel_only $kernel_only
    set temp_temp_ignore_myself $ignore_myself
    set kernel_only $temp_kernel_only
    set ignore_myself $temp_ignore_myself

    # the state of global var is setup we can validate the data
    set valid [validate_advanced_setup]

    if { $valid >= 1 } then {

	# The validation have lose : cancel all the change
	foreach i $var_list {
	    set $i [set temp_$i]
	}

	set kernel_only $temp_temp_kernel_only
	set ignore_myself $temp_temp_ignore_myself
	if { $valid == 1 } then {
	    # user have said cancel
	    destroy .f_advanced_setup
	}
    } else {
	# validation is ok or user have request to ignore error : save the
	# the setup to the configuration file.
	save_advanced_setup gui_advanced_setup 1

	destroy .f_advanced_setup
    }
}

proc onDefaultAdvancedSetup {} {

    load_advanced_setup gui_advanced_setup.defaults

    # kernel_only and ignore_myself are omitted here, they are treated
    # separately in the code.
    set var_list { kernel_filename map_filename buffer_size hash_size
	pid_filter pgrp_filter base_dir samples_dir device_filename
	hashmap_device_file log_filename
    }

    foreach i $var_list {
	global $i
	.f_advanced_setup.$i delete 0 end
	.f_advanced_setup.$i insert end [set $i]
    }

    global temp_kernel_only kernel_only
    set temp_kernel_only $kernel_only
    global temp_ignore_myself ignore_myself
    set temp_ignore_myself $ignore_myself
}

# not reusable : dedicated to be called from onAdvancedSetup proc.
proc create_entry { name label label_name width } {
    global $name

    set f .f_advanced_setup

    entry $f.$name -width $width
    $f.$name insert end [set $name]
    label $f.$label_name -text $label

    pack $f.$label_name $f.$name -side top
}

# show the advanced setup form
proc onAdvancedSetup {} {

    global kernel_filename map_filename buffer_size hash_size
    global pid_filter pgrp_filter
    global base_dir samples_dir 
    global device_filename hashmap_device_file log_filename
    global kernel_only ignore_myself

    set f .f_advanced_setup
    set width 32

    toplevel $f

    wm title $f "Advanced setup"

    create_entry kernel_filename "kernel filename" l1 $width
    create_entry map_filename "System.map" l2 $width
    create_entry buffer_size "buffer size" l3 $width
    create_entry hash_size "hash size" l4 $width
    create_entry pid_filter "pid filter (if compiled in)" l5 $width
    create_entry pgrp_filter "pgrp filter (if compiled in)" l6 $width
    create_entry base_dir "base dir of daemon" l7 $width
    create_entry samples_dir "samples dir file" l8 $width
    create_entry device_filename "device file" l9 $width
    create_entry hashmap_device_file "hash map device" l10 $width
    create_entry log_filename "daemon log file" l11 $width

    # these field are integer only.
    bind $f.buffer_size <Key> { onValidateKey "0123456789" %A }
    bind $f.hash_size <Key> { onValidateKey "0123456789" %A }
    bind $f.pid_filter <Key> { onValidateKey "0123456789" %A }
    bind $f.pgrp_filter <Key> { onValidateKey "0123456789" %A }

    frame $f.cb
    pack $f.cb -side top -fill x

    # -- must use global temporary variable.
    global temp_kernel_only temp_ignore_myself
    set temp_kernel_only $kernel_only
    set temp_ignore_myself $ignore_myself

    checkbutton $f.cb.kernel_only -text "kernel only" -variable temp_kernel_only
    checkbutton $f.cb.ignore_myself -text "ignore myself" -variable temp_ignore_myself

    pack $f.cb.kernel_only $f.cb.ignore_myself -side left

    frame $f.f_btn -borderwidth 1 -relief sunken
    pack $f.f_btn -side top -fill x

    button $f.f_btn.b_ok -text Ok -command "onAdvancedSetupOK"
    button $f.f_btn.b_cancel -text Cancel -command "destroy .f_advanced_setup"
    button $f.f_btn.b_defaults -text Defaults -command "onDefaultAdvancedSetup"

    pack $f.f_btn.b_ok $f.f_btn.b_cancel $f.f_btn.b_defaults -side left -expand yes

    grab $f
}

proc set_default_help_string { hint } {
    set i [search_event $hint]
    if { [llength $i] > 0 } then {
	.status_bar configure -state normal

	.status_bar delete 1.0 end
	.status_bar insert end [lindex $i 3]

	.status_bar configure -state disabled
    }
}

#  Called on mouse motion on the main form to handle the setup of the help
# string in the status bar.
proc onMouseMotion { w } {

    switch -regexp "$w" {
	"\.f_event_type\._.?\.f\.rb.*" {

	    set hint [$w cget -value]

	    set_default_help_string $hint
	}
    }
}

# TODO : This is probably not the right thing to do, particullary
# constant \x7f is probably a bad thing.
proc onValidateKey { allow a } {
#    tk_messageBox -message "\"$a\""

    if { [string first $a $allow] != -1 } then {
	return
    }

    # back space
    if { $a == "\b" } then {
	return
    }

    # accept hard tab
    if { $a  == "	" } then {
	return
    }

    # suppr key : really not cleanly handled.
    if { $a == "\x7f" } then {
	return
    }

    # something like an arrow key, modifier key etc
    if { [string length $a] == 0 } then {
	return
    }

#    tk_messageBox -message "\"$a\""

    return -code break
}

# Called when the user request ok in the f_unit_mask_option form.
#  The main purpose of this proc is to update the global unit_mask
# with the user input into the f_unit_mask_option frame.
proc onOptionMaskOk { counter } {
    global event_type_$counter unit_mask_$counter

    if { [need_unit_mask [set event_type_$counter]] } then {

	set i [search_event [set event_type_$counter]]

	set type_u_mask [lindex $i 5]

	# for exclusive mode, the variable is setup directly by tcl/tk
	if { [str_eq $type_u_mask exclusive]  == 0 } then  {
	    # assert type_u_mask == bit_mask
	    set list [lindex $i 7]

	    set button_order 1
	    set temp 0
	    foreach j $list {
		set btn .f_unit_mask_option.b$button_order

		# I have not found the manner to get the current state of a 
		# checkbutton so I work with global variable.

		global b$button_order

		set var [$btn cget -variable] 
		set temp [expr [set $var] | $temp]

		# The form will be closed : clean up global var.
		# The dialog is not necessarily closed so we need not to destroy
		# the global var. This leads to a minor memory leaks but it can occur
		# only one time by oprofile gui session, so don't worry me about that.
#		unset b$button_order

		incr button_order
	    }

	    if { $temp == 0 } then {
		tk_messageBox -message "unit mask invalid, you must select at least one item for this event type"

		return
	    }
	    
	    set unit_mask_$counter $temp
	}
    } else {
	# maintainers : this means than event_type_list is bad or a bug in
	# the function which translate the event_list.
	tk_messageBox -message \
	    "Internal error [set event_type_$counter] does not require unit mask"
    }

    destroy .f_unit_mask_option
}

# Create the f_unit_mask_option form. Careful this create some global variable
# destroyed by the onOptionMaskOk proc
proc onUnitMaskClick { counter } {

    global event_type_$counter
    global unit_mask_$counter

    set i [search_event [set event_type_$counter]]

    if { [need_unit_mask [set event_type_$counter]] } then {

	toplevel .f_unit_mask_option

	wm title .f_unit_mask_option "unit mask option ([lindex $i 0]-Counter $counter)"

	set type_u_mask [lindex $i 5]
	set default_value [lindex $i 6]
	set list [lindex $i 7]

	# if radiobutton are created this setup the default checked radiobutton
	# here we try to keep the old value of the unit mask as restored from
	# the configuration file.

	# -1 means unit mask has not been set, so in this case we need to put the
	# default value.
	if { [set unit_mask_$counter] == -1 } then {
	    set unit_mask_$counter $default_value
	}

	if { [str_eq $type_u_mask exclusive] == 0 } then {
	    # checkbutton to implement bit_mask
	    set button_order 1
	    foreach j $list {
		set entry b$button_order

		lappend entry [lindex $j 1]

		lappend temp_list $entry

		incr button_order
	    }

	    create_checkbutton_group .f_unit_mask_option. top 0 $temp_list

	    # setup the default value.
	    set button_order 1
	    foreach j $list {
		set btn .f_unit_mask_option.b$button_order

		# I have not found the manner to get the current state of a 
		# checkbutton so I pass through global variable.
		global b$button_order

		set value [lindex $j 0]

		$btn configure -onvalue $value

		# Set the option if unit_mask match the default unit_mask value

		if { ($value & [set unit_mask_$counter]) == $value } then {
		    $btn select
		} else {
		    $btn deselect
		}

		incr button_order
	    }
	} else {
	    # radiobutton to implement exclusive set
	    set button_order 1
	    foreach j $list {

		set entry b$button_order

		lappend entry [ lindex $j 0 ]
		lappend entry [ lindex $j 1 ]

		lappend temp_list $entry

		incr button_order
	    }

	    create_radiobutton_group .f_unit_mask_option. unit_mask_$counter top $temp_list
	}

	# now create the ok cancel button
	set f .f_unit_mask_option.btn

	frame $f -borderwidth 1 -relief sunken
	pack $f -side top -fill x

	button $f.b_ok -text Ok -command "onOptionMaskOk $counter"
	button $f.b_cancel -text Cancel -command "destroy .f_unit_mask_option"

	pack $f.b_ok $f.b_cancel -side left -expand yes

	grab .f_unit_mask_option
    } else {
	# maintainers : this means than event_type_list is bad or a bug in
	# the function which translate the event_list.
	tk_messageBox \
	    -message "Internal error [set event_type_$counter] do not require unit mask"
    }
}

# An event_type radio_button has been clicked. The main purpose of this proc
# is to enabled/disabled the f_unit_mask.f_unit_mask_$counter.btn_unit_mask
proc onRadiobuttonChange { counter } {
    global event_type_$counter
    global old_event_type_$counter

    set button_path .f_unit_mask.f_unit_mask_$counter.btn_unit_mask

    set i [search_event [set event_type_$counter]]

    if { [expr [ llength $i ] > 5] } {
	if { [str_eq [lindex $i 5] mandatory] == 0 } then {
	    $button_path configure -state normal
	} else {
	    $button_path configure -state disabled
	}
    } else {
	$button_path configure -state disabled
    }

    # tricky : need to save the old setup in the array, before restoring it from the
    # current setting...
    set temp_event_type [set event_type_$counter]
    set event_type_$counter [set old_event_type_$counter]

    save_to_array $counter

    set event_type_$counter $temp_event_type

    save_to_global $counter

    set old_event_type_$counter [set event_type_$counter]
}

# Setup all the stuff needed by one counter
proc create_event_frame { parent counter } {
    set w $parent._$counter

    frame $w
    pack $w -side left
    scrollbar $w.sb1 -command "$w.canvas yview"
    pack $w.sb1 -side right -fill y
    canvas $w.canvas -yscrollcommand "$w.sb1 set"
    pack $w.canvas
    frame $w.f

    # create the event list.
    set temp_list [create_event_list $counter]
    create_radiobutton_group $w.f. event_type_$counter top $temp_list

    set f_counter .f_counter.f_counter_$counter

    frame $f_counter
    pack $f_counter -side left
    entry $f_counter.counter_$counter -width 12 -textvariable counter_$counter
    pack $f_counter.counter_$counter -anchor w

    # This field is integer only.
    bind $f_counter.counter_$counter <Key> { onValidateKey "0123456789" %A }

    if { $counter == 1 } then {
	place $f_counter -relx 0.5
    }

    create_checkbutton_group  $f_counter. left 0 {
	{ kernel_count "OS ring count"  }
	{ usr_count "USR ring count" }
    }

    $f_counter.kernel_count configure -variable kernel_count_$counter
    $f_counter.usr_count configure -variable usr_count_$counter

    set f_unit_mask .f_unit_mask.f_unit_mask_$counter
    frame $f_unit_mask
    pack $f_unit_mask -side left

    if { $counter == 1 } then {
	place $f_unit_mask -relx 0.5
    }

    button $f_unit_mask.btn_unit_mask -text "Unit Mask" -command "onUnitMaskClick $counter"
    pack $f_unit_mask.btn_unit_mask
}

# The main procedure.
proc setup_event_frame { } {

    create_event_frame .f_event_type 0
    create_event_frame .f_event_type 1

    # Avoid some screen flick but some wm cannot handle properly this
    #  If you experiment some problem try to comment this line and the 
    # wm deiconify . line
    wm withdraw .

    update idletasks

    set scry [expr [winfo screenh .] / 2]
    set maxy [expr [winfo screenh .] * 3 / 4]

    for { set i 0 } { $i < 2 } { incr i } {
	set f .f_event_type._$i
	$f.canvas create window 0 0 -anchor nw -window $f.f

	$f.canvas configure \
	    -width [winfo reqwidth $f.f] \
	    -scrollregion "0 0 [winfo reqwidth $f.f] [winfo reqheight $f.f]"

	set winy [expr [winfo reqh .] - [winfo reqh $f.f]]
	set canvtotal [expr [winfo reqh $f.f] + 2]
	if [expr $winy + $canvtotal < $maxy] {
	    $f.canvas configure -height $canvtotal
	} else {
	    $f.canvas configure -height [expr $scry - $winy]
	}
    }

    # see comment on wm withdraw and update idletasks
    wm deiconify .
}

# setup global for the current event type.
for { set i 0 } { $i < $max_counter_number } { incr i } {
    save_to_global $i
}

# create and layout the frame container.

# TODO : put all this code in setup_event_frame

# TODO : how to get dynamically the correct width ?
wm geometry . 576x600

frame .f_config_and_start_stop

set f .f_config_and_start_stop

frame $f.f_start_stop -borderwidth 2 -relief sunken
frame $f.f_config -borderwidth 2 -relief sunken
frame .f_event_type -borderwidth 2 -relief sunken
frame .f_counter -borderwidth 2 -relief sunken
frame .f_unit_mask -borderwidth 2 -relief sunken

create_text . status_bar 1 1
pack .status_bar -side bottom -anchor w -fill y -expand yes

bind . <Motion> { onMouseMotion %W }

pack $f .f_counter .f_unit_mask .f_event_type -anchor w -fill x
pack $f.f_start_stop $f.f_config -side top -fill x -expand yes

set f .f_config_and_start_stop.f_start_stop

button $f.b_start -text "Start profiler" -command onStartProfiling -width 16
button $f.b_stop -text "Stop profiler" -command onStopProfiling -width 16
button $f.b_flush -text "Flush profile data" -command onFlushData -width 16

pack $f.b_start $f.b_stop $f.b_flush -side left -expand yes

set f .f_config_and_start_stop.f_config

button $f.b_advanced_setup -text "Advanced setup" -command onAdvancedSetup -width 16
button $f.b_default_setup -text "Load default setup" -command "load_setup gui_setup.defaults 0" -width 16
button $f.b_quit_and_save_setup -text "Quit and save setup" -command "save_setup gui_setup 1\ndestroy ." -width 16

pack $f.b_advanced_setup $f.b_default_setup $f.b_quit_and_save_setup \
    -side left -expand yes

set processor_type -1
set title ""

# Fixme : Celeron Copermine string ?, how to != between a celeron with
# a PII core and a PIII core ? TODO look into the core source file.

set cpuinfo_file [open /proc/cpuinfo r]
while { [gets $cpuinfo_file var] != -1 } {

    switch -regexp "$var" {
	".*Pentium Pro .*" { set processor_type 0; set title "Pentium Pro" }
	".*Pentium II .*"  { set processor_type 1; set title "Pentium II"  }
	".*Celeron .*"     { set processor_type 1; set title "Celeron"     }
	".*Pentium III .*" { set processor_type 2; set title "Pentium III" }
    }
}

# Add this line later when the profiler core support the P4.
#       ".*Pentium IV .*" { set processor_type 3; set title "Pentium IV" }

close $cpuinfo_file

if { [expr $processor_type == -1] } then {
    set answer [tk_messageBox \
	    -message "Cannot detect processor : default to P2" -type okcancel]
    switch $answer {
	cancel { exit 1 }
    }
    set processor_type 1
    set title "Pentium II"
}

wm title . "Profiling option for $title processor"

setup_event_frame

load_setup gui_setup 1

set_default_help_string $event_type_0

# debug : list all the widgets from the desired root.
# proc list_widgets {w {depth 0}} {
#     puts [format "%*s %s is a %s" $depth "" $w [winfo class $w]]
#     foreach child [winfo children $w] {
#         list_widgets $child [expr $depth + 4]
#     }
# }

# list_widgets .
