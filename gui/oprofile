#!/bin/sh
# -*- TCL -*-
# the next line restarts using wish \
exec wish "$0" "$@"

# Do not worry me about problems of design in this file. This is my first
# tcl/tk app so in many case I have write dirty thing to work around
# documentation failure and/or my poor knowledge of tcl/tk, but the 
# script seems to work fine. I need feed back from a tcl/tk wizard on
# many thing in this file.

# global var
global event_type_0 event_type_1
global old_event_type_0 old_event_type_1
global event_type_list
global unit_mask_0 unit_mask_1
global counter_0 counter_1
global usr_count_0 kernel_count_0 usr_count_1 kernel_count_1
global ctr_edge_detect_0 ctr_edge_detect_1
global kernel_filename map_filename
global buffer_size hash_size
global kernel_only ignore_myself
global pid_filter pgrp_filter
global base_dir samples_dir
global device_filename hashmap_device_file log_filename

# This is defined in oprofile.h
global OP_MAX_PERF_COUNT
set OP_MAX_PERF_COUNT 2147483647

set old_event_type_0 ""
set old_event_type_1 ""

#  This section contains the setting of default hard-coded value. They are
# use only if the ~./oprofile/gui_advanced_setup.defaults do not exist else
# this value are overrided by loading the configuration file.
# Must be coherent with op_start and the documentation (not strongly required, 
# this is just required to not confuse the user).

set event_type_0 "CPU_CLK_UNHALTED"
set event_type_1 "DISABLED"

set counter_0 600000
set counter_1 600000

set unit_mask_0 0
set unit_mask_1 0

set ctr_edge_detect_0 0
set ctr_edge_detect_1 0

set usr_count_0 1
set usr_count_1 1
set kernel_count_0 1
set kernel_count_1 1

# In some situation it is incorrect to get the System.map and kernel
# filename from here but this provide a correct default value in many case.
set build_dir [concat /lib/modules/[exec uname -r]/build]
set kernel_filename [concat $build_dir/vmlinux]
set map_filename [concat $build_dir/System.map]

set buffer_size 262144
set hash_size 65536
set kernel_only 0
set ignore_myself 0
set pid_filter 0
set pgrp_filter 0

set base_dir "/var/opd"
set samples_dir "samples"
set device_filename "opdev"
set hashmap_device_file "ophashmapdev"
set log_filename "oprofiled.log"

# end of hard-coded defaults value section

# utilities proc

# item_list: { name text }*
proc create_checkbutton_group { parent_name side width item_list } {
    foreach i $item_list {
	set button_name $parent_name[lindex $i 0]
	set button_text [lindex $i 1]
	checkbutton $button_name -text $button_text -width $width

	if { $side == "top" || $side == "bottom" } then {
	    pack $button_name -side $side -pady 2 -anchor w
	} else {
	    pack $button_name -side $side -pady 2
	}
    }
}

# create a simple text entry optionnally read only.
proc create_text { parent_name name height read_only } {

    set name $parent_name$name

    if { $height <= 0 } then {
	set height [ llength $text ]
    }

    text $name -height $height

    if { $read_only != 0 } then {
	$name configure -state disabled
    }

    pack $name
}

# item_list: { name value text [ { command value }* ] }*
proc create_radiobutton_group { parent_name var_name side item_list } {

    foreach i $item_list {

	set name $parent_name[lindex $i 0]
	set value [lindex $i 1]
	set text [lindex $i 2]

	radiobutton $name -text $text -variable $var_name -value $value

	if [ expr [ llength $i] >= 4 ] then {
	    # TODO : this is not clean but how to pass "-state disabled"
	    # and correctly interpret it here.
	    set cmd [lindex $i 3]
	    $name configure [lindex $cmd 0] [lindex $cmd 1]
	}

	if { $side == "top" || $side == "bottom" } then {
	    pack $name -side $side -pady 2 -anchor w
	} else {
	    pack $name -side $side -pady 2
	}
    }
}


# Return the event entry list for event name hint else an empty list.
proc search_event { hint } {
    global event_type_list

    foreach i $event_type_list {
	if { [lindex $i 0] == $hint } then {
	    return $i
	}
    }

    return { }
}

# Return 1 if the event named hint need a (non-mandatory) unit mask option, 
# else return 0.
proc need_unit_mask { hint } {
    set i [search_event $hint]

    if { [expr [ llength $i ] > 4] && \
	     [string compare [lindex $i 4] mandatory] } then {
	return 1
    } else {
	return 0
    }
}

# return a list usable as the param item_list of create_radiobutton_group.
proc create_event_list { processor_mask counter_mask } {

    global event_type_list

    set j 1

    foreach i $event_type_list {
	set entry rb$j
	lappend entry [ lindex $i 0 ]
	lappend entry [ lindex $i 0 ]

	if { ! ( ( [ lindex $i 1 ] & $processor_mask) &&
	     ( [ lindex $i 2 ] & $counter_mask) )  } then {
	    # TODO : see comment in create_radiobutton_group : it is better
	    # to: lappend entry "-state disabled" but it do not work
	    lappend entry { -state disabled }
	}

	lappend temp_list $entry
	incr j
    }

    return $temp_list;
}

# Start the profiling.
# Some dirty fix in this proc : building completly the command line do not work
# it seems than tcl/tk interpret a var containing  
# --map-file=map_filename --ctr0-count=100000
# as the argument "--map-file=map_filename --ctr0-count" and "=10000".
# Workaround is to build the cmd line separatly
proc onStartProfiling {} {
    global event_type_0 event_type_1
    global counter_0 counter_1
    global kernel_count_0 usr_count_0 kernel_count_1 usr_count_1
    global ctr_edge_detect_0 ctr_edge_detect_1
    global unit_mask_0 unit_mask_1
    global processor_type
    global kernel_filename map_filename
    global buffer_size hash_size
    global kernel_only ignore_myself
    global pid_filter pgrp_filter
    global base_dir samples_dir
    global device_filename hashmap_device_file log_filename

    if { [string compare $event_type_0 DISABLED] == 0 && 
	 [string compare $event_type_1 DISABLED] == 0 } then {
 	tk_messageBox -message "you must enable at least one of the counter"
 	return
    }

    # This can be redundant some times and give twice time the warning message to 
    # the user. Keep it in this way because it is the correct way to encourage user to
    # correctly make the setup :)
    if { [validate_advanced_setup] != 0 } then {
	return
    }

    global OP_MAX_PERF_COUNT

    if { [string compare [set event_type_0] DISABLED] != 0 } then {
	if { $usr_count_0 == 0 && $kernel_count_0 == 0 } then {
	    tk_messageBox -message "You must enable at least one of the USR ring count/OS ring count for counter 0"
	    return
	}

	set message [op_check_range counter_0 500 $OP_MAX_PERF_COUNT]
	if { [string length $message] != 0 } then {
	    set answer [tk_messageBox -type yesno -message \
			    "invalid parameter apply anyway ? :$message"]
	    case $answer {
		no { return }
	    }
	}
    }

    if { [string compare [set event_type_1] DISABLED] != 0 } then {
	if { $usr_count_1 == 0 && $kernel_count_1 == 0 } then {
	    tk_messageBox -message "You must enable at least one of the USR ring count/OS ring count for counter 1"
	    return
	}

	set message [op_check_range counter_1 500 $OP_MAX_PERF_COUNT]
	if { [string length $message] != 0 } then {
	    set answer [tk_messageBox -type yesno -message \
			    "invalid parameter apply anyway ? :$message"]
	    case $answer {
		no { return }
	    }
	}
    }

    # Some other validation needed here ?
    # TODO : do we need more check or lets the op_start/daemon making the 
    # check, the problem is that the op_start/daemon are a little too verbose.
    # The way tcl/tk handle of the error message is not really cleanly.

    # :( redundant code we must separate all case
    if { [string compare [set event_type_0] DISABLED] && 
	 [string compare [set event_type_1] DISABLED] } then {
	# counter 0 / 1 enabled
	tk_messageBox -message "[exec op_start --ctr0-event=$event_type_0 \
	    --ctr0-count=$counter_0 \
	    --ctr0-kernel=$kernel_count_0 \
	    --ctr0-user=$usr_count_0 \
	    --ctr0-unit-mask=$unit_mask_0 \
	    --ctr0-edge-detect=$ctr_edge_detect_0 \
	    --ctr1-event=$event_type_1 \
	    --ctr1-count=$counter_1 \
	    --ctr1-kernel=$kernel_count_1 \
	    --ctr1-user=$usr_count_1 \
	    --ctr1-unit-mask=$unit_mask_1 \
	    --ctr1-edge-detect=$ctr_edge_detect_1 \
	    --use-cpu=$processor_type \
	    --map-file=$map_filename \
	    --vmlinux=$kernel_filename \
	    --ignore-myself=$ignore_myself \
	    --kernel-only=$kernel_only \
	    --pid-filter=$pid_filter \
	    --pgrp-filter=$pgrp_filter \
	    --base-dir=$base_dir \
	    --samples-dir=$base_dir/$samples_dir \
	    --device-file=$base_dir/$device_filename \
	    --hash-map-device-file=$base_dir/$hashmap_device_file \
	    --log-file=$base_dir/$log_filename]\n\
            or to use the Flush profile data button"
    } elseif { [string compare [set event_type_0] DISABLED] != 0 } then {
	# counter 0 only
	tk_messageBox -message "[exec op_start --ctr0-event=$event_type_0 \
	    --ctr0-count=$counter_0 \
	    --ctr0-kernel=$kernel_count_0 \
	    --ctr0-user=$usr_count_0 \
	    --ctr0-unit-mask=$unit_mask_0 \
	    --ctr0-edge-detect=$ctr_edge_detect_0 \
	    --use-cpu=$processor_type \
	    --map-file=$map_filename \
	    --vmlinux=$kernel_filename  \
            --ignore-myself=$ignore_myself \
	    --kernel-only=$kernel_only \
	    --pid-filter=$pid_filter \
	    --pgrp-filter=$pgrp_filter \
	    --base-dir=$base_dir \
	    --samples-dir=$base_dir/$samples_dir \
	    --device-file=$base_dir/$device_filename \
	    --hash-map-device-file=$base_dir/$hashmap_device_file \
	    --log-file=$base_dir/$log_filename]\n\
            or to use the Flush profile data button"
    } else {
	# counter 1 only
	tk_messageBox -message "[exec op_start --ctr1-event=$event_type_1 \
	    --ctr1-count=$counter_1 \
	    --ctr1-kernel=$kernel_count_1 \
	    --ctr1-user=$usr_count_1 \
	    --ctr1-unit-mask=$unit_mask_1 \
	    --ctr1-edge-detect=$ctr_edge_detect_1 \
	    --use-cpu=$processor_type \
	    --map-file=$map_filename \
	    --vmlinux=$kernel_filename  \
	    --ignore-myself=$ignore_myself \
	    --kernel-only=$kernel_only \
	    --pid-filter=$pid_filter \
	    --pgrp-filter=$pgrp_filter \
	    --base-dir=$base_dir \
	    --samples-dir=$base_dir/$samples_dir \
	    --device-file=$base_dir/$device_filename \
	    --hash-map-device-file=$base_dir/$hashmap_device_file \
	    --log-file=$base_dir/$log_filename]\n\
            or to use the Flush profile data button"
    }
}

# Stop the profiling.
proc onStopProfiling {} {
    onFlushData

    tk_messageBox -message [exec op_stop]
}

# Flush the profiling data.
proc onFlushData {} {

    # the user can try to flush even if the driver is not loaded so check for
    # the file existence before attempting to make a flush.
    if { [file exists /proc/sys/dev/oprofile/dump] } then {

	# FIXME : apparently there is no way actually to check if dumping has
	# been done correctly.
	set fd [open /proc/sys/dev/oprofile/dump w]
	puts $fd "1"

	#  Must be enclosed in a catch clause because the driver return a zero
	# file length write (or an error ?), wish interpret this as a write
	# error. Take care it is really needed to catch { flush $fd } instead 
	# of  catch { close $fd } else the tcl/tk runtime leaks a file 
	# descriptor each time this function is called.
	catch { flush $fd }
	close $fd
    }
}

# create the ~/.oprofile dir if it is not exist.
proc auto_create_config_directory {} {
    if { [file isdirectory ~/.oprofile] == 0 } then {
	file mkdir ~/.oprofile
    }
}

# copy filename.defaults to filename if filename does not exist.
proc copy_file_if_not_exist { filename } {

   if { [file exists ~/.oprofile/$filename] == 0 } then {
       set input [open ~/.oprofile/$filename.defaults r]
       set output [open ~/.oprofile/$filename w]

       fcopy $input $output

       close $input
       close $output
    }
}

# auto-create and save the advanced setup file.
proc save_advanced_setup { filename destroy_old_file } {
    auto_create_config_directory

    if { $destroy_old_file == 1 } then {
	file delete ~/.oprofile/$filename
    }

    if { [file exists ~/.oprofile/$filename] == 0 } then {
	set fd [open ~/.oprofile/$filename w]

	puts $fd "# Defaults advanced configuration of start profiler's gui"
	puts $fd "# You can comment this file, comment would not be lost"

	set var_list { kernel_filename map_filename buffer_size hash_size
	    pid_filter pgrp_filter base_dir samples_dir device_filename
	    hashmap_device_file log_filename kernel_only ignore_myself
	}

	foreach i $var_list {
	    global $i

	    puts $fd "$i=[set $i]"
	}

	close $fd
    }
}

# load all the stuff that can be found in the advanced setup form.
proc load_advanced_setup { filename } {

    save_advanced_setup gui_advanced_setup.defaults 0

    copy_file_if_not_exist $filename

    set fd [open ~/.oprofile/$filename r]

    while { [gets $fd temp] != -1 } {
	if { [string first "\#" $temp ] != 0 } then {
	    set list [split $temp "="]

	    set key [lindex $list 0]
	    set value [lindex $list 1]

	    global $key

	    set $key $value
	}
    }

    close $fd
}

# save the setup.
proc save_setup { filename destroy_old_file } {
    auto_create_config_directory

    if { $destroy_old_file == 1 } then {
	file delete ~/.oprofile/$filename
    }

    if { [file exists ~/.oprofile/$filename] == 0 } then {
	set fd [open ~/.oprofile/$filename w]

	puts $fd "# Defaults configuration of start profiler's gui"
	puts $fd "# Do not add comment this file, comment will be lost"

	set var_list { event_type_0 event_type_1 unit_mask_0 unit_mask_1
	    counter_0 counter_1 usr_count_0 kernel_count_0 
	    usr_count_1 kernel_count_1 ctr_edge_detect_0 ctr_edge_detect_1
	}

	foreach i $var_list {
	    global $i

	    puts $fd "$i=[set $i]"
	}

	close $fd
    }

    if { $destroy_old_file == 1 } then {
	save_advanced_setup gui_advanced_setup 1
    }
}

# load the the setup and conditionnaly the advanced setup.
# force_advanced_setup_load :
# 0 : check than the user wants to reload from the defaults.
# 1 : unconditionnaly reload from the current setup
proc load_setup { force_advanced_setup_load } {
    save_setup gui_setup.defaults 0

    copy_file_if_not_exist gui_setup

    set fd [open ~/.oprofile/gui_setup r]

    while { [gets $fd temp] != -1 } {
	if { [string first "\#" $temp ] != 0 } then {
	    set list [split $temp "="]

	    set key [lindex $list 0]
	    set value [lindex $list 1]

	    global $key
	    set $key $value
	}
    }

    close $fd

    if { $force_advanced_setup_load == 0 } then {
        case [tk_messageBox -type yesno -message "Load also the default advanced setup ?"] {
	    yes { set force_advanced_setup_load 2 }
	}
    }

    if { $force_advanced_setup_load >= 1 } then {

	if { $force_advanced_setup_load == 2 } then {
	    load_advanced_setup gui_advanced_setup.defaults
	} else {
	    load_advanced_setup gui_advanced_setup
	}
    }
}

# return an empty string if the range is ok else return 
# "\n\n$prefix not in range :\n$value"
# Note than allowed range is (min, max) and not (min, max( to be coherent with 
# the op_check_range() macro in oprofile.h
proc op_check_range { value min max } {

    global $value

    # this is to be coherent with op_check_range() macro in oprofile.h
    if { [set $value] < $min || [set $value] > $max } then {
	return "\n\n$value is not in the allowed range ($min, $max) :\n[set $value]"
    }

    return ""
}

# return 
# 0 : ok, 
# 1 some problem occur but the user request to ignore it
# 2 some problem occur and the user request a cancel operation.
# For now I disallow the user to try with really invalidate value.
proc validate_advanced_setup {} {
    global kernel_filename map_filename
    global buffer_size hash_size
    # TODO : some of this need validation?
#    global kernel_only ignore_myself
#    global pid_filter pgrp_filter
#    global base_dir samples_dir
#    global device_filename hashmap_device_file log_filename

    set message ""

    if { [file isfile $kernel_filename] == 0 } then {
	set message "\n\nvmlinux does not exist :\n$kernel_filename"
    }

    if { [file isfile $map_filename] == 0 } then {
	set message "$message\n\nSystem.map does not exist :\n$map_filename"
    }

    set message "$message[op_check_range hash_size 256 262144]"
    set message "$message[op_check_range buffer_size 1024 1048576]"

    if { [string length $message] != 0 } then {
        set answer [tk_messageBox -type yesnocancel -message "these paramaters are not correct apply anyway ? :$message"]
              case $answer {
                  yes { return 0 }
                  no { return 1 }
		  cancel { return 2 }
              }


    } else {
	return 0
    }
}

# when the form advanced setup is close by an ok we need to validate/save
# the new contents of this form in the global variable. We also need to save
# here the new settings to persistent storage.
proc onAdvancedSetupOK {} {

    # kernel_only and ignore_myself are omitted here, they are treated
    # separately in the code.
    set var_list { kernel_filename map_filename buffer_size hash_size
	pid_filter pgrp_filter base_dir samples_dir device_filename
	hashmap_device_file log_filename
    }

    global temp_kernel_only temp_ignore_myself kernel_only ignore_myself

    # save locally the change
    foreach i $var_list {
	global $i

	set temp_$i [set $i]

	set $i [.f_advanced_setup.$i get]
    }

    set temp_temp_kernel_only $kernel_only
    set temp_temp_ignore_myself $ignore_myself
    set kernel_only $temp_kernel_only
    set ignore_myself $temp_ignore_myself

    # the state of global var is setup we can validate the data
    set valid [validate_advanced_setup]

    if { $valid >= 1 } then {

	# The validation have lose : cancel all the change
	foreach i $var_list {
	    set $i [set temp_$i]
	}

	set kernel_only $temp_temp_kernel_only
	set ignore_myself $temp_temp_ignore_myself
	if { $valid == 1 } then {
	    # user have said cancel
	    destroy .f_advanced_setup
	}
    } else {
	# validation is ok or user have request to ignore error : save the
	# the setup to the configuration file.
	save_advanced_setup gui_advanced_setup 1

	destroy .f_advanced_setup
    }
}

proc onDefaultAdvancedSetup {} {

    load_advanced_setup gui_advanced_setup.defaults

    # it is normal than kernel_only and ignore_myself are omitted here, they
    # are treated separately in the code.
    set var_list { kernel_filename map_filename buffer_size hash_size
	pid_filter pgrp_filter base_dir samples_dir device_filename
	hashmap_device_file log_filename
    }

    foreach i $var_list {
	global $i
	.f_advanced_setup.$i delete 0 end
	.f_advanced_setup.$i insert end [set $i]
    }

    global temp_kernel_only kernel_only
    set temp_kernel_only $kernel_only
    global temp_ignore_myself ignore_myself
    set temp_ignore_myself $ignore_myself
}

# not reusable : dedicated to be called from onAdvancedSetup proc.
proc create_entry { name value label label_name width } {
    global $name

    set f .f_advanced_setup

    entry $f.$name -width $width
    $f.$name insert end $value
    label $f.$label_name -text $label

    pack $f.$label_name $f.$name -side top
}

# show the advanced setup form
proc onAdvancedSetup {} {

    global kernel_filename map_filename buffer_size hash_size
    global pid_filter pgrp_filter
    global base_dir samples_dir 
    global device_filename hashmap_device_file log_filename
    global kernel_only ignore_myself

    set f .f_advanced_setup
    set width 32

    toplevel $f

    wm title $f "Advanced setup"

    create_entry kernel_filename $kernel_filename "kernel filename" l1 $width
    create_entry map_filename $map_filename "System.map" l2 $width
    create_entry buffer_size $buffer_size "buffer size" l3 $width
    create_entry hash_size $hash_size "hash size" l4 $width
    create_entry pid_filter $pid_filter "pid filter (if compiled in)" l5 $width
    create_entry pgrp_filter $pgrp_filter "pgrp filter (if compiled in)" l6 $width
    create_entry base_dir $base_dir "base dir of daemon" l7 $width
    create_entry samples_dir $samples_dir "samples dir file" l8 $width
    create_entry device_filename $device_filename "device file" l9 $width
    create_entry hashmap_device_file $hashmap_device_file "hash map device" l10 $width
    create_entry log_filename $log_filename "daemon log file" l11 $width

    frame $f.cb
    pack $f.cb -side top -fill x

    # -- must use global temporary variable.
    global temp_kernel_only temp_ignore_myself
    set temp_kernel_only $kernel_only
    set temp_ignore_myself $ignore_myself

    checkbutton $f.cb.kernel_only -text "kernel only" -variable temp_kernel_only
    checkbutton $f.cb.ignore_myself -text "ignore myself" -variable temp_ignore_myself

    pack $f.cb.kernel_only $f.cb.ignore_myself -side left

    frame $f.f_btn -borderwidth 1 -relief sunken
    pack $f.f_btn -side top -fill x

    button $f.f_btn.b_ok -text Ok -command "onAdvancedSetupOK"
    button $f.f_btn.b_cancel -text Cancel -command "destroy .f_advanced_setup"
    button $f.f_btn.b_defaults -text Defaults -command "onDefaultAdvancedSetup"

    pack $f.f_btn.b_ok $f.f_btn.b_cancel $f.f_btn.b_defaults -side left -expand yes

    grab $f
}

proc set_default_help_string { hint } {
    set i [search_event $hint]
    if { [llength $i] > 0 } then {
	.status_bar configure -state normal

	.status_bar delete 1.0 end
	.status_bar insert end [lindex $i 3]

	.status_bar configure -state disabled
    }
}

#  Called on mouse motion on the main form to handle the setup of the help
# string in the status bar. Unhopefully this proc is not called if the user
# scroll with the keyboard and the mouse pointer is inside a radiobutton.
#  Perhaps an event such as onActivate will work better.
proc onMouseMotion { w } {

    switch -regexp "$w" {
	"\.f_event_type\._.?\.f\.rb.*" {

	    set hint [$w cget -value]

	    set_default_help_string $hint
	}
    }
}

# Called when the user request ok in the f_unit_mask_option form.
#  The main purpose of this proc is to update the global unit_mask_[0|1]
# with the user input into the f_unit_mask_option frame.
proc onOptionMaskOk { counter } {
    global event_type_$counter unit_mask_$counter

    set i [search_event [set event_type_$counter]]

    set type_u_mask [lindex $i 4]
    set default_value [lindex $i 5]
    set list [lindex $i 6]

    set temp 0

    if { [need_unit_mask [set event_type_$counter]] } then {

	set type_u_mask [lindex $i 4]

	# for exclusive mode, the variable is setup directly by tcl/tk
	if { [string compare $type_u_mask exclusive ] } then  {
	    # assert type_u_mask == bit_mask
	    set list [lindex $i 6]

	    # need a two pass algorithm, the first ensure than the umask is ok, then
	    # if ok the second pass destroy global var. For now i do not delete global
	    # var

	    set button_order 1
	    set temp 0
	    foreach j $list {
		set btn .f_unit_mask_option.b$button_order

		# I have not found the manner to get the current state of a 
		# checkbutton so I work with global variable.

		global b$button_order

		set var [$btn cget -variable] 
		set temp [expr [set $var] | $temp]

		# The form will be closed : clean up global var.
		# Phe : the dialog is not neccessarily closed so we need to not
		# destroy the global var. This leads to a minor memory leaks but
		# it can occur only one time by oprofile gui session, so don't worry
		# me about that.
#		unset b$button_order

		incr button_order
	    }

	    if { $temp == 0 } then {
		tk_messageBox -message "unit mask invalid, you must select at least one item for this event type"

		return
	    }
	    
	    set unit_mask_$counter $temp
	}
    } else {
	# maintainers : this means than event_type_list is bad or a bug in
	# the function which translate the event_list.
	tk_messageBox \
	    -message \
	    "Internal error [set event_type_$counter] do not require unit mask"
    }

    destroy .f_unit_mask_option
}

# Create the f_unit_mask_option form. Carefull this create some global variable
# destroyed by the onOptionMaskOk proc
proc onUnitMaskClick { counter } {

    global event_type_$counter
    global unit_mask_$counter

    set i [search_event [set event_type_$counter]]

    if { [need_unit_mask [set event_type_$counter]] } then {

	toplevel .f_unit_mask_option

	wm title .f_unit_mask_option \
	    "unit mask option ([lindex $i 0]-Counter $counter)"

	set type_u_mask [lindex $i 4]
	set default_value [lindex $i 5]
	set list [lindex $i 6]

	global unit_mask_$counter

	# if radiobutton are created this setup the default checked radiobutton
	# here we try to keep the old value of the unit mask as restored from
	# the configuration file.
	if { [set unit_mask_$counter] == 0 } then {
	    set unit_mask_$counter $default_value
	}

	if { [string compare $type_u_mask exclusive] } then {
	    # checkbutton to implement bit_mask
	    set button_order 1
	    foreach j $list {
		set entry b$button_order

		lappend entry [lindex $j 1]

		lappend temp_list $entry

		incr button_order
	    }

	    create_checkbutton_group .f_unit_mask_option. top 0 $temp_list

	    # setup the default value.
	    set button_order 1
	    foreach j $list {
		set btn .f_unit_mask_option.b$button_order

		# I have not found the manner to get the current state of a 
		# checkbutton so I pass through global variable.
		global b$button_order

		set value [lindex $j 0]

		$btn configure -onvalue $value

		# Set the option if unit_mask match the default unit_mask value

		if { ($value & [set unit_mask_$counter]) == $value } then {
		    $btn select
		} else {
		    $btn deselect
		}

		incr button_order
	    }
	} else {
	    # radiobutton to implement exclusive set
	    set button_order 1
	    foreach j $list {

		set entry b$button_order

		lappend entry [ lindex $j 0 ]
		lappend entry [ lindex $j 1 ]

		lappend temp_list $entry

		incr button_order
	    }

	    create_radiobutton_group .f_unit_mask_option. \
		unit_mask_option_$counter top $temp_list
	}

	# now create the ok cancel button
	set f .f_unit_mask_option.btn

	frame $f -borderwidth 1 -relief sunken
	pack $f -side top -fill x

	button $f.b_ok -text Ok -command "onOptionMaskOk $counter"
	button $f.b_cancel -text Cancel -command "destroy .f_unit_mask_option"

	pack $f.b_ok $f.b_cancel -side left -expand yes

	grab .f_unit_mask_option
    } else {
	# maintainers : this means than event_type_list is bad or a bug in
	# the function which translate the event_list.
	tk_messageBox \
	    -message \
	    "Internal error [set event_type_$counter] do not require unit mask"
    }
}

# An event_type radio_button has been clicked. The main purpose of this proc
# is to enabled/disabled the f_unit_mask.f_unit_mask_$counter.btn_unit_mask
proc onRadiobuttonChange { counter reset_unit_mask } {
    global event_type_$counter
    global old_event_type_$counter
    global unit_mask_$counter

    set button_path .f_unit_mask.f_unit_mask_$counter.btn_unit_mask

    set i [search_event [set event_type_$counter]]

    # This test is needed to avoid unecessary reset of the unit_mask
    # Note than the unit_mask is never saved in the config file neither
    # saved here : setting the masking, changing the event, reputting the old
    # event then the mask is reseted. TODO : fix this
    if { [string compare [set old_event_type_$counter] \
	      [set event_type_$counter]] } then {
	if { [expr [ llength $i ] > 4] } {
	    if { [string compare [lindex $i 4] mandatory] } then {
		$button_path configure -state normal
	    } else {
		$button_path configure -state disabled
	    }

	    set default_value [lindex $i 5]

	    if { $reset_unit_mask } then {
		set unit_mask_$counter $default_value
	    }
	} else {
	    $button_path configure -state disabled

 	    set unit_mask_$counter 0
	}

	set old_event_type_$counter [set event_type_$counter]
    }
}

# Setup all the stuff needed by one counter
proc create_event_frame { parent counter processor_type } {
    set w $parent._$counter

    set counter_mask [expr 1 << $counter ]
    set processor_mask [expr 1 << $processor_type]

    frame $w
    pack $w -side left
    scrollbar $w.sb1 -command "$w.canvas yview"
    pack $w.sb1 -side right -fill y
    canvas $w.canvas -yscrollcommand "$w.sb1 set"
    frame  $w.f
    pack $w.canvas

    # create the event list.
    set temp_list [create_event_list $processor_mask $counter_mask]
    create_radiobutton_group $w.f. event_type_$counter top $temp_list

    # configure the cmd for checkbutton
    foreach i $temp_list  {
	set button $w.f.[lindex $i 0]
	$button configure -command "onRadiobuttonChange $counter 1"
	# TODO : button are not correctly expanded
#	pack $button -side top -fill x -anchor w -expand yes
    }

    # TODO how to constrain editable text to be an integer ?
    set f_counter .f_counter.f_counter_$counter

    frame $f_counter
    pack $f_counter -side left
    entry $f_counter.counter_$counter -width 12 -textvariable counter_$counter
    pack $f_counter.counter_$counter -anchor w

    if { $counter == 1 } then {
	place $f_counter -relx 0.5
    }

    # this creation order is required to have a correct layout of the button.

    create_checkbutton_group  $f_counter. bottom 0 {
	{ edge_detect "Edge detect" }
    }

    create_checkbutton_group  $f_counter. left 0 {
	{ kernel_count "OS ring count"  }
	{ usr_count "USR ring count" }
    }

    global usr_count_$counter kernel_count_$counter ctr_edge_detect_$counter

    $f_counter.kernel_count configure -variable kernel_count_$counter
    $f_counter.usr_count configure -variable usr_count_$counter
    $f_counter.edge_detect configure -variable ctr_edge_detect_$counter

    set f_unit_mask .f_unit_mask.f_unit_mask_$counter
    frame $f_unit_mask
    pack $f_unit_mask -side left

    if { $counter == 1 } then {
	place $f_unit_mask -relx 0.5
    }

    button $f_unit_mask.btn_unit_mask -text "Unit Mask" -state disabled \
	-command "onUnitMaskClick $counter"
    pack $f_unit_mask.btn_unit_mask
}

# The main procedure.
proc setup_event_frame { processor } {

    create_event_frame .f_event_type 0 $processor
    create_event_frame .f_event_type 1 $processor

    # Avoid some screen flick but some wm cannot handle properly this
    #  If you experiment some problem try to comment this line and the 
    # wm deiconify . line
    wm withdraw .

    update idletasks

    set scry [expr [winfo screenh .] / 2]
    set maxy [expr [winfo screenh .] * 3 / 4]

    for { set i 0 } { $i < 2 } { incr i } {
	set f .f_event_type._$i
	$f.canvas create window 0 0 -anchor nw -window $f.f

	$f.canvas configure \
	    -width [winfo reqwidth $f.f] \
	    -scrollregion "0 0 [winfo reqwidth $f.f] [winfo reqheight $f.f]"

	set winy [expr [winfo reqh .] - [winfo reqh $f.f]]
	set canvtotal [expr [winfo reqh $f.f] + 2]
	if [expr $winy + $canvtotal < $maxy] {
	    $f.canvas configure -height $canvtotal
	} else {
	    $f.canvas configure -height [expr $scry - $winy]
	}
    }

    # see comment on wm withdraw  and update idletasks
    wm deiconify .
}

# create and layout the frame container.

# TODO : put all this code in setup_event_frame
load_setup 1

# TODO : how to get dynamically the correct width ?
wm geometry . 576x600

frame .f_config_and_start_stop

set f .f_config_and_start_stop

frame $f.f_start_stop -borderwidth 2 -relief sunken
frame $f.f_config -borderwidth 2 -relief sunken
frame .f_event_type -borderwidth 2 -relief sunken
frame .f_counter -borderwidth 2 -relief sunken
frame .f_unit_mask -borderwidth 2 -relief sunken

create_text . status_bar 1 1
pack .status_bar -side bottom -anchor w -fill y -expand yes

bind . <Motion> { onMouseMotion %W }

pack $f .f_counter .f_unit_mask .f_event_type -anchor w -fill x
pack $f.f_start_stop $f.f_config -side top -fill x -expand yes

set f .f_config_and_start_stop.f_start_stop

# TODO : check if profiling is already started ?
button $f.b_start -text "Start profiler" -command onStartProfiling -width 16
button $f.b_stop -text "Stop profiler" -command onStopProfiling -width 16
button $f.b_flush -text "Flush profile data" -command onFlushData -width 16

pack $f.b_start $f.b_stop $f.b_flush -side left -expand yes

set f .f_config_and_start_stop.f_config

button $f.b_advanced_setup -text "Advanced setup" -command onAdvancedSetup -width 16
button $f.b_default_setup -text "Load default setup" -command "load_setup 0" -width 16
button $f.b_quit_and_save_setup -text "Quit and save setup" -command "save_setup gui_setup 1\ndestroy ." -width 16

pack $f.b_advanced_setup $f.b_default_setup $f.b_quit_and_save_setup \
    -side left -expand yes

set processor_type -1
set title ""

set cpuinfo_file [open /proc/cpuinfo r]
while { [gets $cpuinfo_file var] != -1 } {

    switch -regexp "$var" {
	".*Pentium Pro .*" { set processor_type 0; set title "Pentium Pro" }
	".*Pentium II .*"  { set processor_type 1; set title "Pentium II"  }
	".*Celeron .*"     { set processor_type 1; set title "Celeron"     }
	".*Pentium III .*" { set processor_type 2; set title "Pentium III" }
    }
}

# Add this line later when the profiler core support the P4.
#       ".*Pentium IV .*" { set processor_type 3; set title "Pentium IV" }

close $cpuinfo_file

if { [expr $processor_type == -1] } then {
    set answer [tk_messageBox \
	    -message "Cannot detect processor : default to P2" -type okcancel]
    switch $answer {
	cancel { exit 1 }
    }
    set processor_type 1
    set title "Pentium II"
}

wm title . "Profiling option for $title processor"

#  This list is here to avoid maintaining separate list for each processor
# type / counter number. It is the main data structure which describe all
# counter event. When adding new processor/event/counter only this data
# structure need update (adding counter require also work in the code).

# TODO : this must be shared in some way with op_events.c

# list entry item :
# 1 event type/name
# 2 bit mask 
#  1 : avail for PPro
#  2 : avail for P2
#  4 : avail for P3
#  8 : avail fo P4  currently not supported.
# 3 bit mask
#  1 : available for counter 0
#  2 : available for counter 1
# 4 help string displayed in the status bar.
# optionnal args follow :
# 5 a string in { mandatory bit_mask exclusive }
#  mandatory entry are event that need this particular value for this event
#  bit_mask means the different value can be or'ed
#  exclusive means than only one of ths value can be passed to thep profiler.
# 6 the default value
# 7 a list of  : { unit_bit_mask_or_value string }+
set event_type_list {
    { DISABLED 255 255 "Select it to disable this counter" }
    { CPU_CLK_UNHALTED 7 3 "Clock processor not halted" }
    { DATA_MEM_REFS 7 3 "All memory reference, cachable and non" }
    { DCU_LINES_IN  7 3 "Total line allocated in DCU" }
    { DCU_M_LINES_IN  7 3 "Number of M state lines allocated in DCU" }
    { DCU_M_LINES_OUT  7 3 "Number of M lines evicted from the DCU" }
    { DCU_MISS_OUTSTANDING 7 3 "Number of cycles while DCU miss outstanding" }
    { IFU_IFETCH 7 3 "Number of non/cachable instruction fetches" }
    { IFU_IFETCH_MISS 7 3 "Number of instruction fetch misses" }
    { ITLB_MISS 7 3 "Number of ITLB misses" }
    { IFU_MEM_STALL 7 3 "Cycles instruction fetch pipe is stalled" }
    { ILD_STALL 7 3 "Cycles instruction length decoder is stalled" }
    { L2_IFETCH 7 3 "Number of L2 instruction fetches"
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	} 
    }
    { L2_LD 7 3 "Number of L2 data load"
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	} 
    }
    { L2_ST 7 3 "Number of L2 data stores"
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	}
    }
    { L2_LINES_IN 7 3 "Number of allocated lines in L2" }
    { L2_LINES_OUT 7 3 "Number of recovered lines from L2" }
    { L2_M_LINES_INM 7 3 "Number of modified lines allocated in L2" }
    { L2_M_LINES_OUTM 7 3 "Number of modified lines removed from L2" }
    { L2_RQSTS 7 3 "Number of L2 requests"
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	}
    }
    { L2_ADS 7 3 "Number of L2 address strobes" }
    { L2_DBUS_BUSY 7 3 "Number of cycles data bus was busy" }
    { L2_DMUS_BUSY_RD 7 3 "Cycles data bus was busy in xfer from L2 to cpu" }
    { BUS_DRDY_CLOCKS 7 3 "Number of clocks DRDY is asserted" 
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_LOCK_CLOCKS 7 3 "Number of clocks LOCK is asserted" 
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_REQ_OUTSTANDING 7 3 "Number of outstanding bus request" }
    { BUS_TRAN_BRD 7 3 "Number of burst read transactions" 
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_RFO 7 3 "Number of read for ownership transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_WB 7 3 "Number of write back transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_IFETCH 7 3 "Number of instruction fetch transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_INVAL 7 3 "Number of invalid transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_PWR 7 3 "umber of partial write transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_P 7 3 "Number of parial transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_IO 7 3 "Number of I/O transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_DEF 7 3 "Number of deferred transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}    
    }
    { BUS_TRAN_BURST 7 3 "Number of burst transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_ANY 7 3 "Number of all transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_MEM 7 3 "Number of memory transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_DATA_RCV 7 3 "Bus cycles this processor is receiving data" }
    { BUS_BNR_DRV 7 3 "bus cycles this processor is driving BNR pin" }
    { BUS_HIT_DRV 7 3 "bus cycles this processor is driving HIT pin" }
    { BUS_HITM_DRV 7 3 "bus cycles this processor is driving HITM pin" }
    { BUS_SNOOP_STALL 7 3 "cycles during bus snoop stall" }
    { COMP_FLOP_RET 7 1 \
	  "Number of computational FP operations retired - Counter 0 only" }
    { FLOPS 7 1 \
	  "Number of computational FP operations executed - Counter 0 only" }
    { FP_ASSIST 7 2 \
	"Number of exceptions handled by microcode - Counter 1 only" }
    { MUL 7 2 "Number of multiplies - Counter 1 only" }
    { DIV 7 2 "Number of divides - Counter 1 only" }
    { CYCLES_DIV_BUSY 7 1 "Cycles divider is busy - Counter 0 only" }
    { LD_BLOCKS 7 3 "Number of store blocks" }
    { SB_DRAINS 7 3 "Number of store buffer drain cycles" }
    { MISALIGN_MEM_REF 7 3 "Number of misaligned data memory references" }
    { EMON_KNI_PREF_DISPATCHED 4 3
	  "Number KNU pre-fetch/weakly ordered insns dispatch - P3 only"
	exclusive 0
	{ 
	    { 0 "Prefecth NTA" }
	    { 1 "Prefetch T1" }
	    { 2 "Prefetch T2" }
	    { 3 "weakly ordered stores" }
	} 
    }
    { EMON_KNI_PREF_MISS 4 3
      "Number KNU pre-fetch/weakly ordered insns that miss all cache - P3 only"
	exclusive 0
	{
	    { 0 "Prefecth NTA" }
	    { 1 "Prefetch T1" }
	    { 2 "Prefetch T2" }
	    { 3 "weakly ordered stores" }
	}
    }
    { INST_RETIRED 7 3 "Number of instructions retired" }
    { UOPS_RETIRED 7 3 "Number of UOPs retired" }
    { INST_DECODED 7 3 "Number of instructions decoded" }
    { EMON_KNI_INST_RETIRED 4 3 "Number of KNI instructions retired - P3 only"
	exclusive 0
	{
	    { 0 "Packed and scalar" }
	    { 1 "Packed" }
	}
    }
    { EMON_KNI_COMP_INST_RET 4 3 
	"Number of KNI instructions computation retired - P3 only"
	exclusive 0
	{ 
	    { 0 "Packed and scalar" }
	    { 1 "Packed" }
	} 
    }
    { HW_INT_RX 7 3 "Number of hardware interrupts received" }
    { CYCLES_INT_MASKED 7 3 "Cycles interrupt are disabled" }
    { CYCLES_INT_PENDING_AND_MASKED 7 3 
	"Cycles interrupts are disabled with pending interrupts" }
    { BR_INST_RETIRED 7 3 "Number of branch instructions retired" }
    { BR_MISS_PRED_RETIRED 7 3 "Number of mispredicted branches retired" }
    { BR_TAKEN_RETIRED 7 3 "Number of taken branches retired" }
    { BR_MISS_PRED_TAKEN_RET 7 3 
	"Number of taken mispredictions branches retired" }
    { BR_INST_DECODED 7 3 "Number of branches instructions decoded" }
    { BTB_MISSES 7 3 "Number of branches that miss the BTB" }
    { BR_BOGUS 7 3 "Number of bogus branches" }
    { BACLEARS 7 3 "Number of times BACLEAR is asserted" }
    { RESOURCE_STALLS 7 3 "Cycles during resource related stalls" }
    { PARTIAL_RAT_STALLS 7 3 "cycles or event for partial stalls" }
    { SEGMENT_REG_LOADS 7 3 "Number of segment register loads" }
    { MMX_INSTR_EXEC 2 3 "Number of MMX instructions executed - P2 only" }
    { MMX_SAT_INSTR_EXEC 6 3 
	"Number of MMX saturating instructions executed - P2/P3 only" }
    { MMX_UOPS_EXEC 6 3 "Number of MMX UOPs executed - P2/P3 only"
	mandatory 15
	{
	    { 15 "Mandatory" }
	}
    }
    { MMX_INSTR_TYPE_EXEC 6 3 "Number of MMX packing instructions - P2/P3 only"
	bit_mask 63
	{
	    { 1 "MMX packed multiplies" }
	    { 2 "MMX packed shifts" }
	    { 4 "MMX pack operations" }
	    { 8 "MMX unpack operations" }
	    { 16 "MMX packed logical" }
	    { 32 "MMX packed arithmetic" }
	    { 63 "MMX pack/unpack and all operations" }
	}
    }
    { FP_MMX_TRANS 6 3 "MMX-floating point transitions - P2/P3 only"
	exclusive 0
	{
	    { 0 "Transitions from MMX to floating point" }
	    { 1 "Transitions from floating point to MMX" }
	}
    }
    { MMX_ASSIST 6 3 "Number of EMMS instructions executed - P2/P3 only" }
    { MMX_INSTR_RET 2 3 "Number of MMX instructions retired - P2 only" }
    { SEG_RENAME_STALLS 6 3 \
	  "Number of segment register renaming stalls - P2/P3 only" 
	bit_mask 15
	{
	    { 1 "ES register" }
	    { 2 "DS register" }
	    { 4 "FS register" }
	    { 8 "GS register" }
	    { 15 "ES, DS, FS, GS register" }
	}
    }
    { SEG_REG_RENAMES 6 3  "Number of segment register renames - P2/P3 only"
	bit_mask 15
	{
	    { 1 "ES register" }
	    { 2 "DS register" }
	    { 4 "FS register" }
	    { 8 "GS register" }
	    { 15 "ES, DS, FS, GS register" }
	}
    }
    { RET_SEG_RENAMES 6 3 \
	  "Number of segment register rename events retired - P2/P3 only" }
}

setup_event_frame $processor_type

# this is needed to enable/disable the unit_mask option and to ensure than
# the unit_mask_option is correctly setup.
onRadiobuttonChange 0 0
onRadiobuttonChange 1 0

set_default_help_string $event_type_0
