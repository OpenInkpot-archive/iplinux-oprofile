#!/bin/sh
# -*- TCL -*-
# the next line restarts using wish \
exec wish "$0" "$@"

# Do not worry me about problems of design in this file. This is my first
# tcl/tk app so in many case I have write dirty thing to work around
# documentation failure and/or my poor knowledge of tcl/tk, but the 
# script work fine ;), I would clean up later.

# global var
global event_type_0 event_type_1
global old_event_type_0 old_event_type_1
global event_type_list
global bit_mask_option_0 bit_mask_option_1
global counter_0 counter_1
global usr_count_0 kernel_count_0 usr_count_1 kernel_count 1
global vmlinux map_file

set bit_mask_option_0 0
set bit_mask_option_1 0
set vmlinux "/boot/vmlinuz-2.4.3"
set map_file "/boot/System-2.4.3.map"

# utilities proc

# item_list: { name text }*
proc create_checkbutton_group { parent_name side width item_list } {
    foreach i $item_list {
	set button_name $parent_name[lindex $i 0]
	set button_text [lindex $i 1]
	checkbutton $button_name -text $button_text -width $width

	if { $side == "top" || $side == "bottom" } then {
	    pack $button_name -side $side -pady 2 -anchor w
	} else {
	    pack $button_name -side $side -pady 2
	}
    }
}

proc create_text { parent_name name height read_only text } {

    set name $parent_name$name

    if { $height <= 0 } then {
	set height [ llength $text ]
    }

    text $name -height $height

    foreach i $text {
	$name insert end $i
    }

    if { $read_only != 0 } then {
	$name configure -state disabled
    }

    pack $name
}


# item_list: { name value text [ { command value }* ] }*
proc create_radiobutton_group { parent_name var_name side item_list } {

    foreach i $item_list {

	set name $parent_name[lindex $i 0]
	set value [lindex $i 1]
	set text [lindex $i 2]

	radiobutton $name -text $text -variable $var_name -value $value

	if [ expr [ llength $i] >= 4 ] then {
	    # TODO : this is not clean but how to pass "-state disabled"
	    # and correctly interpret it here.
	    set cmd [lindex $i 3]
	    $name configure [lindex $cmd 0] [lindex $cmd 1]
	}

	if { $side == "top" || $side == "bottom" } then {
	    pack $name -side $side -pady 2 -anchor w
	} else {
	    pack $name -side $side -pady 2
	}
    }
}


# Return the event entry list for event name hint else an empty list.
proc search_event { hint } {
    global event_type_list

    foreach i $event_type_list {
	if { [lindex $i 0] == $hint } then {
	    return $i
	}
    }

    return { }
}

# Return 1 if the event named hint need a (non-mandatory) unit mask option, 
# else return 0.
proc need_unit_mask { hint } {
    set i [search_event $hint]

    if { [expr [ llength $i ] > 4] && \
	     [string compare [lindex $i 4] mandatory] } then {
	return 1
    } else {
	return 0
    }
}

# return a list usable as the param item_list of create_radiobutton_group.
proc create_event_list { processor_mask counter_mask } {

    global event_type_list

    set j 1

    foreach i $event_type_list {
	set entry rb$j
	lappend entry [ lindex $i 0 ]
	lappend entry [ lindex $i 0 ]

	if { ! ( ( [ lindex $i 1 ] & $processor_mask) &&
	     ( [ lindex $i 2 ] & $counter_mask) )  } then {
	    # TODO : see comment in create_radiobutton_group : it is better
	    # to: lappend entry "-state disabled" but it do not work
	    lappend entry { -state disabled }
	}

	lappend temp_list $entry
	incr j
    }

    return $temp_list;
}

# Start the profiling.
# Some dirty fix in this proc : building completly the command line do not work
# it seems than tcl/tk interpret a var containing  
# --map-file=map_file --ctr0-count=100000
# as the argument "--map-file=map_file --ctr0-count" and "=10000".
# Workaround is to build the cmd line separatly
proc onStartProfiling {} {
    global event_type_0 event_type_1
    global counter_0 counter_1
    global kernel_count_0 usr_count_0 kernel_count_1 usr_count_1
    global bit_mask_option_0 bit_mask_option_1
    global processor_type
    global vmlinux map_file

    if { [string compare [set event_type_0] DISABLED] == 0 && 
	 [string compare [set event_type_1] DISABLED] == 0 } then {
 	tk_messageBox -message "you must enable at least one of the counter"
 	return;
    }

    # TODO : do we need more check or lets the op_start/daemon making the 
    # check, the problem is that the op_start/daemon are a little too verbose.
    # tcl/tk handle the error message not really cleanly.

    # :( redundant code we must separate all case
    if { [string compare [set event_type_0] DISABLED] && 
	 [string compare [set event_type_1] DISABLED] } then {
	# counter 0 / 1 enabled
	exec op_start --ctr0-event=$event_type_0 \
	    --ctr0-count=$counter_0 \
	    --ctr0-kernel=$kernel_count_0 \
	    --ctr0-user=$usr_count_0 \
	    --ctr0-unit-mask=$bit_mask_option_0 \
	    --ctr1-event=$event_type_1 \
	    --ctr1-count=$counter_1 \
	    --ctr1-kernel=$kernel_count_1 \
	    --ctr1-user=$usr_count_1 \
	    --ctr1-unit-mask=$bit_mask_option_1 \
	    --use-cpu=$processor_type \
	    --map-file=$map_file \
	    --vmlinux=$vmlinux > /dev/stdout
    } elseif { [string compare [set event_type_0] DISABLED] != 0 } then {
	# counter 0 only
	exec op_start --ctr0-event=$event_type_0 \
	    --ctr0-count=$counter_0 \
	    --ctr0-kernel=$kernel_count_0 \
	    --ctr0-user=$usr_count_0 \
	    --ctr0-unit-mask=$bit_mask_option_0 \
	    --use-cpu=$processor_type \
	    --map-file=$map_file \
	    --vmlinux=$vmlinux > /dev/stdout
    } else {
	# counter 1 only
	exec op_start --ctr1-event=$event_type_1 \
	    --ctr1-count=$counter_1 \
	    --ctr1-kernel=$kernel_count_1 \
	    --ctr1-user=$usr_count_1 \
	    --ctr1-unit-mask=$bit_mask_option_1 \
	    --use-cpu=$processor_type \
	    --map-file=$map_file \
	    --vmlinux=$vmlinux > /dev/stdout
    }
}

# Stop the profiling.
proc onStopProfiling {} {
    # FIXME : Flushing data is required (or better) ?
#    onFlushData
    exec op_stop > /dev/stdout
}

# Flush the profiling data.
proc onFlushData {} {

    # FIXME : apparently there is no way actually to check if dumping has
    # been done correctly.

    set fd [open /proc/sys/dev/oprofile/dump w]
    puts $fd "1"

    #  Must be enclosed in a catch clause because the driver return a zero
    # file length write (or an error ?), wish interpret this as a write error.
    # Take care if you catch { close $fd } instead of catch { flush } / close
    # the tcl/tk runtime leaks a file descriptor each time this function is 
    # called.
    catch { flush $fd }
    close $fd
}

#  Called on mouse motion on the main form to handle the setup of the help
# string in the status bar. Unhopefully this proc is not called if the user
# scroll with the keyboard and the mouse pointer is inside a radiobutton.
#  Perhaps an event such as onActivate will work better.
proc onMouseMotion { w } {

    switch -regexp "$w" {
	"\.f_event_type\._.?\.f\.rb.*" {
	    # find the event name.
	    set hint [$w cget -value]

	    set i [search_event $hint]
	    if { [llength $i] > 0 } then {
		.status_bar configure -state normal

		.status_bar delete 1.0 end
		.status_bar insert end [lindex $i 3]

		.status_bar configure -state disabled
	    }
	}
    }
}

# Called when the user request ok in the f_unit_mask_option form.
#  The main purpose of this proc is to update the global bit_mask_option_[0|1]
# with the user input into the f_unit_mask_option frame.
proc onOptionMaskOk { counter } {
    global event_type_$counter bit_mask_option_$counter

    set i [search_event [set event_type_$counter]]

    set type_u_mask [lindex $i 4]
    set default_value [lindex $i 5]
    set list [lindex $i 6]

    set temp 0

    if { [expr [ llength $i ] > 4] && \
	     [string compare [lindex $i 4] mandatory] } then {

	set type_u_mask [lindex $i 4]

	# for exclusive mode, the variable is setup directly by tcl/tk
	if { [string compare $type_u_mask exclusive ] } then  {
	    # assert type_u_mask == bit_mask
	    set list [lindex $i 6]

	    set button_order 1
	    set temp 0
	    foreach j $list {
		set btn .f_unit_mask_option.b$button_order

		# I have not found the manner to get the current state of a 
		# checkbutton so I work with global variable.

		global b$button_order

		set var [$btn cget -variable] 
		set temp [expr [set $var] | $temp]

		# The form will be closed : clean up global var.
		unset b$button_order

		incr button_order
	    }
	    
	    set bit_mask_option_$counter $temp
	}
    } else {
	# maintainers : this means than event_type_list is bad or a bug in
	# the function which translate the event_list.
	tk_messageBox \
	    -message \
	    "Internal error [set event_type_$counter] do not require unit mask"
    }

    destroy .f_unit_mask_option
}

# Create the f_unit_mask_option form. Carefull this create some global variable
# destroyed by the onOptionMaskOk proc
proc onUnitMaskClick { counter } {

    global event_type_$counter

    set i [search_event [set event_type_$counter]]

    if { [expr [ llength $i ] > 4] && \
	     [string compare [lindex $i 4] mandatory] } then {

	toplevel .f_unit_mask_option

	wm title .f_unit_mask_option \
	    "unit mask option ([lindex $i 0]-Counter $counter)"

	set type_u_mask [lindex $i 4]
	set default_value [lindex $i 5]
	set list [lindex $i 6]

	global bit_mask_option_$counter

	# if radiobutton are created this setup the default checked radiobutton
	set bit_mask_option_$counter $default_value

	if { [string compare $type_u_mask exclusive] } then {
	    # checkbutton to implement bit_mask
	    set button_order 1
	    foreach j $list {
		set entry b$button_order

		lappend entry [lindex $j 1]

		lappend temp_list $entry

		incr button_order
	    }

	    create_checkbutton_group .f_unit_mask_option. top 0 $temp_list

	    # setup the default value.
	    set button_order 1
	    foreach j $list {
		set btn .f_unit_mask_option.b$button_order

		# I have not found the manner to get the current state of a 
		# checkbutton so I pass through global variable.
		global b$button_order

		set value [lindex $j 0]

		$btn configure -onvalue $value

		# TODO : change here to remember old option set because
		# it can be annoying for user to remake the unit mask option
		# each time it change the event selection ? think about that
		# it is not clear what is the right way.

		# Set the option if bitmask match the default bitmask value.

		if { ($value & $default_value) == $value } then {
		    $btn select
		} else {
		    $btn deselect
		}

		incr button_order
	    }
	} else {
	    # radiobutton to implement exclusive set
	    set button_order 1
	    foreach j $list {

		set entry b$button_order

		lappend entry [ lindex $j 0 ]
		lappend entry [ lindex $j 1 ]

		lappend temp_list $entry

		incr button_order
	    }

	    create_radiobutton_group .f_unit_mask_option. \
		bit_mask_option_$counter top $temp_list
	}

	# now create the ok cancel button
	set f .f_unit_mask_option.btn
	frame $f -borderwidth 1 -relief sunken
	pack $f -side top -fill x
	button $f.b_ok -text Ok -command "onOptionMaskOk $counter"
	# TODO : must specify a proc to make the cleanup of global var.
	button $f.b_cancel -text Cancel -command "destroy .f_unit_mask_option"
	pack $f.b_ok $f.b_cancel -side left -expand yes

	grab .f_unit_mask_option
    } else {
	# maintainers : this means than event_type_list is bad or a bug in
	# the function which translate the event_list.
	tk_messageBox \
	    -message \
	    "Internal error [set event_type_$counter] do not require unit mask"
    }
}

# An event_type radio_button has been clicked. The main purpose of this proc
# is to enabled/disabled the f_unit_mask.f_unit_mask_$counter.btn_uint_mask
proc onRadiobuttonChange { button counter } {
    global event_type_$counter
    global old_event_type_$counter
    global bit_mask_option_$counter

    # TODO : must recall the last button change to avoid resetting the
    # unit mask option.

    set button_path .f_unit_mask.f_unit_mask_$counter.btn_unit_mask

    set i [search_event [set event_type_$counter]]

    if { [string compare [set old_event_type_$counter] \
	      [set event_type_$counter]] } then {
	if { [expr [ llength $i ] > 4] } {
	    if { [string compare [lindex $i 4] mandatory] } then {
		$button_path configure -state normal
	    } else {
		$button_path configure -state disabled
	    }

	    set default_value [lindex $i 5]

	    set bit_mask_option_$counter $default_value
	} else {
	    $button_path configure -state disabled

 	    set bit_mask_option_$counter 0
	}

	set old_event_type_$counter [set event_type_$counter]
    }
}

# Setup all the stuff needed by one counter
proc create_event_frame { parent counter processor_type } {
    set w $parent._$counter

    set counter_mask [expr 1 << $counter ]
    set processor_mask [expr 1 << $processor_type]

    frame $w
    pack $w -side left
    scrollbar $w.sb1 -command "$w.canvas yview"
    pack $w.sb1 -side right -fill y
    canvas $w.canvas -yscrollcommand "$w.sb1 set"
    frame  $w.f
    pack $w.canvas

    # create the event list.
    set temp_list [create_event_list $processor_mask $counter_mask]
    create_radiobutton_group $w.f. event_type_$counter top $temp_list

    # configure the cmd for checkbutton
    foreach i $temp_list  {
	set button $w.f.[lindex $i 0]
	$button configure -command "onRadiobuttonChange $button $counter"
	# TODO : button are not correctly expanded
#	pack $button -side top -fill x -anchor w -expand yes
    }

    # TODO how to constrain editable text to be an integer ?
    # TODO width = 12 is bad ?
    # TODO limit the range of edit ?
    set f_counter .f_counter.f_counter_$counter

    global counter_$counter
    set counter_$counter 100000

    frame $f_counter
    pack $f_counter -side left
    entry $f_counter.counter_$counter -width 12 -textvariable counter_$counter
    pack $f_counter.counter_$counter -anchor w

    if { $counter == 1 } then {
	place $f_counter -relx 0.5
    }

    global event_type_$counter old_event_type_$counter
    set event_type_$counter DISABLED
    set old_event_type_$counter ""

    create_checkbutton_group  $f_counter. left 0 {
	{ kernel_count "OS ring count"  }
	{ usr_count "USR ring count" }
    }

    global usr_count_$counter kernel_count_$counter
    set usr_count_$counter 1
    set kernel_count_$counter 0

    $f_counter.kernel_count configure -variable kernel_count_$counter
    $f_counter.usr_count configure -variable usr_count_$counter

    set f_unit_mask .f_unit_mask.f_unit_mask_$counter
    frame $f_unit_mask
    pack $f_unit_mask -side left

    if { $counter == 1 } then {
	place $f_unit_mask -relx 0.5
    }

    button $f_unit_mask.btn_unit_mask -text "Unit Mask" -state disabled \
	-command "onUnitMaskClick $counter"
    pack $f_unit_mask.btn_unit_mask
}

# The main procedure.
proc setup_event_frame { processor } {

    create_event_frame .f_event_type 0 $processor
    create_event_frame .f_event_type 1 $processor

    # Avoid some screen flick but some wm cannot handle properly this
    #  If you experiment some problem try to comment this line and the 
    # wm deiconify . line
    wm withdraw .

    update idletasks

    set scry [expr [winfo screenh .] / 2]
    set maxy [expr [winfo screenh .] * 3 / 4]

    for { set i 0 } { $i < 2 } { incr i } {
	set f .f_event_type._$i
	$f.canvas create window 0 0 -anchor nw -window $f.f

	$f.canvas configure \
	    -width [winfo reqwidth $f.f] \
	    -scrollregion "0 0 [winfo reqwidth $f.f] [winfo reqheight $f.f]"

	set winy [expr [winfo reqh .] - [winfo reqh $f.f]]
	set canvtotal [expr [winfo reqh $f.f] + 2]
	if [expr $winy + $canvtotal < $maxy] {
	    $f.canvas configure -height $canvtotal
	} else {
	    $f.canvas configure -height [expr $scry - $winy]
	}
    }

    # see comment on wm withdraw  and update idletasks
    wm deiconify .
}

# create and layout the frame container.

# TODO : put all this code in setup_event_frame

# TODO : how to get dynamically the correct width ?
wm geometry . 576x600

frame .f_start_stop -borderwidth 2 -relief sunken
frame .f_event_type -borderwidth 2 -relief sunken
frame .f_counter -borderwidth 2 -relief sunken
frame .f_unit_mask -borderwidth 2 -relief sunken

create_text . status_bar 2 1 { }
pack .status_bar -side bottom -anchor w -fill y -expand yes

bind . <Motion> { onMouseMotion %W }

pack .f_start_stop .f_counter .f_unit_mask .f_event_type -anchor w -fill x

# TODO : check if profiling is already started
button .f_start_stop.b_start -text "Start profiling" -command onStartProfiling
button .f_start_stop.b_stop -text "Stop profiling" -command onStopProfiling
button .f_start_stop.b_flush -text "Flush profile data" -command onFlushData

pack .f_start_stop.b_start .f_start_stop.b_stop .f_start_stop.b_flush \
    -side left -expand yes

set processor_type -1
set title ""

set cpuinfo_file [open /proc/cpuinfo r]
while { [gets $cpuinfo_file var] != -1 } {

    # TODO : check if this is correct.
    switch -regexp "$var" {
	".*Pentium Pro .*" { set processor_type 0; set title "Pentium Pro" }
	".*Pentium II .*"  { set processor_type 1; set title "Pentium II"  }
	".*Celeron .*"     { set processor_type 1; set title "Celeron"     }
	".*Pentium III .*" { set processor_type 2; set title "Pentium III" }
    }
}

# Add this line later when the profiler core support the P4.
#       ".*Pentium IV .*" { set processor_type 3; set title "Pentium IV" }

close $cpuinfo_file

if { [expr $processor_type == -1] } then {
    set answer [tk_messageBox \
	    -message "Cannot detect processor : default to P2" -type okcancel]
    switch $answer {
	cancel { exit 1 }
    }
    set processor_type 1
    set title "Pentium II"
}

wm title . "Profiling option for $title processor"

#  This list is here to avoid maintaining separate list for each processor
# type / counter number. It is the main data structure which describe all
# counter event. When adding new processor/event/counter only this data
# structure need update (adding counter require also work in the code).

# TODO : this must be shared in some way with op_events.c

# list entry item :
# 1 event type/name
# 2 bit mask 
#  1 : avail for PPro
#  2 : avail for P2
#  4 : avail for P3
#  8 : avail fo P4  currently not supported.
# 3 bit mask
#  1 : available for counter 0
#  2 : available for counter 1
# 4 help string displayed in the status bar.
# optionnal args follow :
# 5 a string in { mandatory bit_mask exclusive }
#  mandatory entry are event that need this particular value for this event
#  bit_mask means the different value can be or'ed
#  exclusive means than only one of ths value can be passed to thep profiler.
# 6 the default value
# 7 a list of  : { unit_bit_mask_or_value string }+
# TODO : tcl allow efficient symbolic constant rather than bitmask ?
set event_type_list {
    { DISABLED 255 255 "Select it to disable this counter" }
    { CPU_CLK_UNHALTED 7 3 "Clock processor not halted" }
    { DATA_MEM_REFS 7 3 "All memory reference, cachable and non" }
    { DCU_LINES_IN  7 3 "Total line allocated in DCU" }
    { DCU_M_LINES_IN  7 3 "Number of M state lines allocated in DCU" }
    { DCU_M_LINES_OUT  7 3 "Number of M lines evicted from the DCU" }
    { DCU_MISS_OUTSTANDING 7 3 "Number of cycles while DCU miss outstanding" }
    { IFU_IFETCH 7 3 "Number of non/cachable instruction fetches" }
    { IFU_IFETCH_MISS 7 3 "Number of instruction fetch misses" }
    { ITLB_MISS 7 3 "Number of ITLB misses" }
    { IFU_MEM_STALL 7 3 "Cycles instruction fetch pipe is stalled" }
    { ILD_STALL 7 3 "Cycles instruction length decoder is stalled" }
    { L2_IFETCH 7 3 "Number of L2 instruction fetches"
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	} 
    }
    { L2_LD 7 3 "Number of L2 data load"
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	} 
    }
    { L2_ST 7 3 "Number of L2 data stores"
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	}
    }
    { L2_LINES_IN 7 3 "Number of allocated lines in L2" }
    { L2_LINES_OUT 7 3 "Number of recovered lines from L2" }
    { L2_M_LINES_INM 7 3 "Number of modified lines allocated in L2" }
    { L2_M_LINES_OUTM 7 3 "Number of modified lines removed from L2" }
    { L2_RQSTS 7 3 "Number of L2 requests"
	bit_mask 15
	{ 
	    { 1 "(I)nvalid cache state" }
	    { 2 "(S)hared cache state" }
	    { 4 "(E)xclusive cache state" }
	    { 8 "(M)odified cache state" }
	    { 15 "MESI cache state" }
	}
    }
    { L2_ADS 7 3 "Number of L2 address strobes" }
    { L2_DBUS_BUSY 7 3 "Number of cycles data bus was busy" }
    { L2_DMUS_BUSY_RD 7 3 "Cycles data bus was busy in xfer from L2 to cpu" }
    { BUS_DRDY_CLOCKS 7 3 "Number of clocs DRDY is asserted" 
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_LOCK_CLOCKS 7 3 "Number of clocks LOCK is asserted" 
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_REQ_OUTSTANDING 7 3 "Number of outstanding bus request" }
    { BUS_TRAN_BRD 7 3 "Number of burst read transactions" 
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_RFO 7 3 "Number of read for ownership transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_WB 7 3 "Number of write back transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_IFETCH 7 3 "Number of instruction fetch transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_INVAL 7 3 "Number of invalid transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_PWR 7 3 "umber of partial write transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_P 7 3 "Number of parial transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_IO 7 3 "Number of I/O transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRANS_DEF 7 3 "Number of deferred transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}    
    }
    { BUS_TRAN_BURST 7 3 "Number of burst transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_ANY 7 3 "Number of all transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_TRAN_MEM 7 3 "Number of memory transactions"
	exclusive 32
	{
	    { 0 "self-generated transactions" }
	    { 32 "any transitions" }
	}
    }
    { BUS_DATA_RCV 7 3 "Bus cycles this processor is receiving data" }
    { BUS_BNR_DRV 7 3 "bus cycles this processor is driving BNR pin" }
    { BUS_HIT_DRV 7 3 "bus cycles this processor is driving HIT pin" }
    { BUS_HITM_DRV 7 3 "bus cycles this processor is driving HITM pin" }
    { BUS_SNOOP_STALL 7 3 "cycles during bus snoop stall" }
    { COMP_FLOP_RET 7 1 \
	  "Number of computational FP operations retired - Counter 0 only" }
    { FLOPS 7 1 \
	  "Number of computational FP operations executed - Counter 0 only" }
    { FP_ASSIST 7 2 \
	"Number of exceptions handled by microcode - Counter 1 only" }
    { MUL 7 2 "Number of multiplies - Counter 1 only" }
    { DIV 7 2 "Number of divides - Counter 1 only" }
    { CYCLES_DIV_BUSY 7 1 "Cycles divider is busy - Counter 0 only" }
    { LD_BLOCKS 7 3 "Number of store blocks" }
    { SB_DRAINS 7 3 "Number of store buffer drain cycles" }
    { MISALIGN_MEM_REF 7 3 "Number of misaligned data memory references" }
    { EMON_KNI_PREF_DISPATCHED 4 3
	  "Number KNU pre-fetch/weakly ordered insns dispatch - P3 only"
	exclusive 0
	{ 
	    { 0 "Prefecth NTA" }
	    { 1 "Prefetch T1" }
	    { 2 "Prefetch T2" }
	    { 3 "weakly ordered stores" }
	} 
    }
    { EMON_KNI_PREF_MISS 4 3
      "Number KNU pre-fetch/weakly ordered insns that miss all cache - P3 only"
	exclusive 0
	{
	    { 0 "Prefecth NTA" }
	    { 1 "Prefetch T1" }
	    { 2 "Prefetch T2" }
	    { 3 "weakly ordered stores" }
	}
    }
    { INST_RETIRED 7 3 "Number of instructions retired" }
    { UOPS_RETIRED 7 3 "Number of UOPs retired" }
    { INST_DECODED 7 3 "Number of instructions decoded" }
    { EMON_KNI_INST_RETIRED 4 3 "Number of KNI instructions retired - P3 only"
	exclusive 0
	{
	    { 0 "Packed and scalar" }
	    { 1 "Packed" }
	}
    }
    { EMON_KNI_COMP_INST_RET 4 3 
	"Number of KNI instructions computation retired - P3 only"
	exclusive 0
	{ 
	    { 0 "Packed and scalar" }
	    { 1 "Packed" }
	} 
    }
    { HW_INT_RX 7 3 "Number of hardware interrupts received" }
    { CYCLES_INT_MASKED 7 3 "Cycles interrupt are disabled" }
    { CYCLES_INT_PENDING_AND_MASKED 7 3 
	"Cycles interrupts are disabled with pending interrupts" }
    { BR_INST_RETIRED 7 3 "Number of branch instructions retired" }
    { BR_MISS_PRED_RETIRED 7 3 "Number of mispredicted branches retired" }
    { BR_TAKEN_RETIRED 7 3 "Number of taken branches retired" }
    { BR_MISS_PRED_TAKEN_RET 7 3 
	"Number of taken mispredictions branches retired" }
    { BR_INST_DECODED 7 3 "Number of branches instructions decoded" }
    { BTB_MISSES 7 3 "Number of branches that miss the BTB" }
    { BR_BOGUS 7 3 "Number of bogus branches" }
    { BACLEARS 7 3 "Number of times BACLEAR is asserted" }
    { RESOURCE_STALLS 7 3 "Cycles during resource related stalls" }
    { PARTIAL_RAT_STALLS 7 3 "cycles or event for partial stalls" }
    { SEGMENT_REG_LOADS 7 3 "Number of segment register loads" }
    { MMX_INSTR_EXEC 2 3 "Number of MMX instructions executed - P2 only" }
    { MMX_SAT_INSTR_EXEC 6 3 
	"Number of MMX saturating instructions executed - P2/P3 only" }
    { MMX_UOPS_EXEC 6 3 "Number of MMX UOPs executed - P2/P3 only"
	mandatory 15
	{
	    { 15 "Mandatory" }
	}
    }
    { MMX_INSTR_TYPE_EXEC 6 3 "Number of MMX packing instructions - P2/P3 only"
	bit_mask 63
	{
	    { 1 "MMX packed multiplies" }
	    { 2 "MMX packed shifts" }
	    { 4 "MMX pack operations" }
	    { 8 "MMX unpack operations" }
	    { 16 "MMX packed logical" }
	    { 32 "MMX packed arithmetic" }
	    { 63 "MMX pack/unpack and all operations" }
	}
    }
    { FP_MMX_TRANS 6 3 "MMX-floating point transitions - P2/P3 only"
	exclusive 0
	{
	    { 0 "Transitions from MMX to floating point" }
	    { 1 "Transitions from floating point to MMX" }
	}
    }
    { MMX_ASSIST 6 3 "Number of EMMS instructions executed - P2/P3 only" }
    { MMX_INSTR_RET 2 3 "Number of MMX instructions retired - P2 only" }
    { SEG_RENAME_STALLS 6 3 \
	  "Number of segment register renaming stalls - P2/P3 only" 
	bit_mask 15
	{
	    { 1 "ES register" }
	    { 2 "DS register" }
	    { 4 "FS register" }
	    { 8 "GS register" }
	    { 15 "ES, DS, FS, GS register" }
	}
    }
    { SEG_REG_RENAMES 6 3  "Number of segment register renames - P2/P3 only"
	bit_mask 15
	{
	    { 1 "ES register" }
	    { 2 "DS register" }
	    { 4 "FS register" }
	    { 8 "GS register" }
	    { 15 "ES, DS, FS, GS register" }
	}
    }
    { RET_SEG_RENAMES 6 3 \
	  "Number of segment register rename events retired - P2/P3 only" }
}

setup_event_frame $processor_type
