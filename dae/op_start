#!/bin/bash
# $Id$
# COPYRIGHT (C) 2000 THE VICTORIA UNIVERSITY OF MANCHESTER and John Levon
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place - Suite 330, Boston, MA 02111-1307, USA.
#

# quick and ugly interface
# op_start --help and op_start --list-events have info

SYSCTL=do_sysctl

#  A replacement function for the sysctl (procps package) utility which is
# missing on some distribution (e.g. slack 7.0). 
#  Handle only the -w option of sysctl.
do_sysctl()
{
	if [ x$1 != x"-w" ]; then
		echo "$0 unknown option" >&2
		exit 1
	fi

	shift

	arg=`echo $1 | awk -F= '{print $1}'`
	val=`echo $1 | awk -F= '{print $2}'`

	dev_name=`echo $arg | tr . /`

	if [ ! -f /proc/sys/$dev_name ]; then
		echo "/proc/sys/$dev_name does not exist or is not a regular file" >&2
		exit 1
	fi
	echo $val > /proc/sys/$dev_name
}

# extract the integer field N from --ctr[N]-xxxxxxx
extract_int()
{
	local val=`echo $1 | sed 's,--ctr\([0-9]*\)[-A-Za-z]*,\1,'`

	if test -z "$val"; then 
		echo "invalid option \"$1\"" >&2
		exit 1
	fi
	if (($val >= $OP_MAX_COUNTERS || $val < 0)); then
		echo "invalid argument $1: bad counter number" >&2
		exit 1
	fi
	echo $val
}

# verbose echo
vecho() {
	if [ "$VERBOSE" == "0" ]; then 
		return;
	fi
	echo $@
}
 
# print help message
do_help() { 
	echo "op_start: usage:
	Module options
	  --buffer-size=num            number of samples in kernel buffer
	  --hash-table-size=num        number of entries in kernel hash table
	  --note-table-size	       number of notes in kernel notes buffer
	  --kernel-only=[0|1]          profile only the kernel
	  --ctrN-event=name            symbolic event name for ctr N
	  --ctrN-count=val             number of events between samples for ctr N
	  --ctrN-unit-mask=val         unit mask for ctr N
	  --ctrN-kernel=[0|1]          whether to count kernel events for ctr N
	  --ctrN-user=[0|1]            whether to count user events for ctr N
	Allowed range for N is [0-$MAX_COUNTER]
	  --pid-filter=pid             Only profile process pid 
	  --pgrp-filter=pgrp           Only profile process group pgrp

	Daemon options
	  --ignore-myself=[0|1]        ignore samples for oprofiled
	  --log-file=file              log file
	  --base-dir=dir               base directory of daemon
	  --samples-dir=file           output samples directory
	  --device-file=file           profile device file
	  --note-device-file=file      note device file
	  --hash-map-device-file=file  profile hash map device file
	  --map-file=file              System.map for running kernel file
	  --vmlinux=file               vmlinux kernel image
	  --verbose                    be verbose in the daemon log

	General options
	  --list-events                list event types and unit masks
	  --help                       this message" >&2
}

# initialise parameters
do_init() {
	LOG_FILE=
	SAMPLES_DIR=
	DEVICE_FILE=
	NOTE_DEVICE_FILE=
	HASH_MAP_DEVICE_FILE=
	BUF_SIZE=262144
	HASH_SIZE=65536
	NOTE_SIZE=8192
	KERNEL_ONLY=0
	IGNORE_MYSELF=0
	DIR="/var/opd"
	MAP_FILE=
	VMLINUX=
	PID_FILTER=0
	PGRP_FILTER=0
	VERBOSE=0

	CPUTYPE=`op_help --get-cpu-type`

	case "$CPUTYPE" in
		0|1|2)
			OP_MAX_COUNTERS=2
			MAX_COUNTER=1
			;;
		3)
			OP_MAX_COUNTERS=4
			MAX_COUNTER=3
			;;
		*)
			echo "Unknown cpu type \"$CPUTYPE\"" >&2
			exit 1
			;;
	esac

	# we can now default define individual counter setup variable.
	f=0
	while (( $f < $OP_MAX_COUNTERS )); do
		CTR_USER[$f]=1
		CTR_KERNEL[$f]=1
		f=$(($f+1))
	done
} 


# get and check specified options
do_options() {
	while [ "$#" -ne 0 ]
	do
		arg=`echo $1 | awk -F= '{print $1}'`
		val=`echo $1 | awk -F= '{print $2}'`
		case "$arg" in
			--ignore-myself)
				if [ "$val" != "" ]; then
					IGNORE_MYSELF=$val
				else
					IGNORE_MYSELF=1
				fi
				;;
			--buffer-size)
				BUF_SIZE=$val
				;;
			--hash-table-size)
				HASH_SIZE=$val
				;;
			--kernel-only)
				if [ "$val" != "" ]; then
					KERNEL_ONLY=$val
				else
					KERNEL_ONLY=1
				fi
				;;
			--ctr*-unit-mask)
				CTR_UM[`extract_int $arg`]=$val
				;;
			--ctr*-event)
				CTR_EVENT[`extract_int $arg`]=$val
				;;
			--ctr*-count)
				CTR_COUNT[`extract_int $arg`]=$val
				;;
			--ctr*-user)
				CTR_USER[`extract_int $arg`]=$val
				;;
			--ctr*-kernel)
				CTR_KERNEL[`extract_int $arg`]=$val
				;;
			--base-dir)
				DIR=$val
				;;
			--samples-dir)
				SAMPLES_DIR=$val
				;;
			--log-file)
				LOG_FILE=$val
				;;
			--device-file)
				DEVICE_FILE=$val
				;;
			--note-device-file)
				NOTE_DEVICE_FILE=$val
				;;
			--hash-map-device-file)
				HASH_MAP_DEVICE_FILE=$val
				;;
			--map-file)
				MAP_FILE=$val
				;;
			--note-table-size)
				NOTE_SIZE=$val
				;;
			--vmlinux)
				VMLINUX=$val
				;;
			--pid-filter)
				PID_FILTER=$val
				;;
			--pgrp-filter)
				PGRP_FILTER=$val
				;;
			--verbose)
				VERBOSE=1
				;;
			--help)
				do_help
				exit 0
				;;

			--list-events)
				exec op_help
				;;
			*)
				echo "Unknown option \"$arg\". See op_start --help" >&2
				exit 1
				;; 
		esac
		shift
	done
 
	one_enabled=0
	f=0
	while (( $f < $OP_MAX_COUNTERS )); do
		if [[ ${#CTR_EVENT[$f]} != 0 ]]; then
			CTR_EVENT_VAL[$f]=`op_help ${CTR_EVENT[$f]}`
			if [ "$?" != 0 ] || [ -z "${CTR_EVENT_VAL[$f]}" -a ! -z "${CTR_EVENT[$f]}" ]; then
				echo "Unknown event \"${CTR_EVENT[$f]}\"" >&2
				exit 1
			fi
			if [ -z "${CTR_COUNT[$f]}" ]; then
				echo "Event but no count specified for counter $f" >&2
				exit 1
			fi
			one_enabled=1
		else 
			if [ ! -z "${CTR_COUNT[$f]}" ]; then
				echo "Count but no event specified for counter $f" >&2
				exit 1
			fi
		fi
		f=$(($f+1))
	done
 
	if [ "$one_enabled" == "0" ]; then
		echo "You haven't specified what events you would like to count, e.g." >&2
		echo "op_start ... --ctr0-event=CPU_CLK_UNHALTED --ctr0-count=600000" >&2
		echo "Enter op_start --help for full options" >&2
		exit 1
	fi

	if [ "$LOG_FILE" = "" ]; then
		LOG_FILE="$DIR/oprofiled.log"
	fi
	if [ "$SAMPLES_DIR" = "" ]; then
		SAMPLES_DIR="$DIR/samples/"
	fi
	if [ "$DEVICE_FILE" = "" ]; then
		DEVICE_FILE="$DIR/opdev"
	fi
	if [ "$NOTE_DEVICE_FILE" = "" ]; then
		NOTE_DEVICE_FILE="$DIR/opnotedev"
	fi
	if [ "$HASH_MAP_DEVICE_FILE" = "" ]; then
		HASH_MAP_DEVICE_FILE="$DIR/ophashmapdev"
	fi

	vecho "Parameters used:"
	vecho "BUF_SIZE $BUF_SIZE"
	vecho "HASH_SIZE $HASH_SIZE"
	vecho "NOTE_SIZE $NOTE_SIZE"
	f=0
	while (( $f < $OP_MAX_COUNTERS )); do
		vecho "CTR${f}_EVENT ${CTR_EVENT[$f]}"
		vecho "CTR${f}_COUNT ${CTR_COUNT[$f]}"
		vecho "CTR${f}_UM ${CTR_UM[$f]}"
		vecho "CTR${f}_USER ${CTR_USER[$f]}"
		vecho "CTR${f}_KERNEL ${CTR_KERNEL[$f]}"
		f=$(($f+1))
	done
	vecho "CPUTYPE $CPUTYPE"
	vecho "IGNORE_MYSELF $IGNORE_MYSELF"
	vecho "DIR $DIR"
	vecho "LOG_FILE $LOG_FILE"
	vecho "SAMPLES_DIR $SAMPLES_DIR"
	vecho "DEVICE_FILE $DEVICE_FILE"
	vecho "NOTE_DEVICE_FILE $NOTE_DEVICE_FILE"
	vecho "HASH_MAP_DEVICE_FILE $HASH_MAP_DEVICE_FILE"
	vecho "MAP_FILE $MAP_FILE"
	vecho "VMLINUX $VMLINUX"

	if [ -z "$MAP_FILE" ]; then
		echo "No map file specified. You must specify the correct System.map and vmlinux files, e.g." >&2
		echo "op_start --map-file=/path/to/System.map --vmlinux=/path/to/vmlinux" >&2
		echo "Enter op_start --help for full options" >&2
		exit 1
	fi

	if [ -z "$VMLINUX" ]; then
		echo "No vmlinux file specified. You must specify the correct System.map and vmlinux files, e.g." >&2
		echo "op_start --map-file=/path/to/System.map --vmlinux=/path/to/vmlinux" >&2
		echo "Enter op_start --help for full options" >&2
		exit 1
	fi

	if [ ! -f "$MAP_FILE" ]; then
		echo "The specified map file \"$MAP_FILE\" doesn't exist." >&2
		exit 1
	fi

	if [ ! -f "$VMLINUX" ]; then
		echo "The specified vmlinux file \"$VMLINUX\" doesn't exist." >&2
		exit 1
	fi
}

# stop any existing daemon
do_stop() {
	op_stop
}

# setup and start module
do_setup() {
	grep oprof /proc/devices >/dev/null
	if [ "$?" -ne 0 ]; then
		modprobe oprofile expected_cpu_type=$CPUTYPE
		if [ "$?" != "0" ]; then
			echo "Couldn't load oprofile.o module" >&2
			exit 1
		fi
		grep oprofile /proc/modules >/dev/null
		if [ "$?" != "0" ]; then
			echo "Couldn't load oprofile.o module" >&2
			exit 1
		fi
	fi

	if [ ! -d "$DIR" ]; then
	       mkdir -p "$DIR"
	       if [ "$?" != "0" ]; then
		       echo "Couldn't mkdir -p $DIR" >&2
		       exit 1
	       fi
	       chmod 755 "$DIR"
	fi

	>$LOG_FILE

	if [ -c "$DEVICE_FILE" ]; then
		vecho "Removing $DEVICE_FILE"
		rm "$DEVICE_FILE"
	fi

	if [ -c "$NOTE_DEVICE_FILE" ]; then
		vecho "Removing $NOTE_DEVICE_FILE"
		rm "$NOTE_DEVICE_FILE"
	fi
 
	if [ -c "$HASH_MAP_DEVICE_FILE" ]; then
		vecho "Removing $HASH_MAP_DEVICE_FILE"
		rm "$HASH_MAP_DEVICE_FILE"
	fi

	if [ ! -d "$SAMPLES_DIR" ]; then
		mkdir -p "$SAMPLES_DIR"
		if [ "$?" != "0" ]; then
			echo "Couldn't mkdir -p $SAMPLES_DIR" >&2
			exit 1
		fi
		chmod 755 "$SAMPLES_DIR"
	fi

	MAJOR_NR=`grep oprof /proc/devices | awk '{print $1}'`

	vecho "Doing mknod $DEVICE_FILE"
	mknod "$DEVICE_FILE" c $MAJOR_NR 0
	if [ "$?" != "0" ]; then
		echo "Couldn't mknod $DEVICE_FILE" >&2
		exit 1
	fi
	chmod 700 "$DEVICE_FILE"
	 
	vecho "Doing mknod $NOTE_DEVICE_FILE"
	mknod "$NOTE_DEVICE_FILE" c $MAJOR_NR 2
	if [ "$?" != "0" ]; then
		echo "Couldn't mknod $NOTE_DEVICE_FILE" >&2
		exit 1
	fi
	chmod 700 "$NOTE_DEVICE_FILE"
 
	vecho "Doing mknod $HASH_MAP_DEVICE_FILE"
	mknod "$HASH_MAP_DEVICE_FILE" c $MAJOR_NR 1
	if [ "$?" != "0" ]; then
		echo "Couldn't mknod $HASH_MAP_DEVICE_FILE" >&2
		exit 1
	fi
	chmod 700 "$HASH_MAP_DEVICE_FILE"
}
 
# initialise sysctl parameters
do_sysctl_setup() {
	# Necessary in this case :
	# op_start ctr0-on ctr1-on then op_start ctr0-on
	f=0
	while (( $f < $OP_MAX_COUNTERS )); do
		$SYSCTL -w dev.oprofile.$f.enabled=0 >/dev/null
		$SYSCTL -w dev.oprofile.$f.event=0 >/dev/null
		f=$(($f+1))
	done

	$SYSCTL -w dev.oprofile.hashsize=$HASH_SIZE
	$SYSCTL -w dev.oprofile.bufsize=$BUF_SIZE
	$SYSCTL -w dev.oprofile.notesize=$NOTE_SIZE
	$SYSCTL -w dev.oprofile.kernel_only=$KERNEL_ONLY
	$SYSCTL -w dev.oprofile.pid_filter=$PID_FILTER
	$SYSCTL -w dev.oprofile.pgrp_filter=$PGRP_FILTER

	f=0
	while (( $f < $OP_MAX_COUNTERS )); do
		if [ "${CTR_EVENT[$f]}" != "" ]; then
			$SYSCTL -w dev.oprofile.$f.enabled=1
			$SYSCTL -w dev.oprofile.$f.count=${CTR_COUNT[$f]}
			$SYSCTL -w dev.oprofile.$f.kernel=${CTR_KERNEL[$f]}
			$SYSCTL -w dev.oprofile.$f.user=${CTR_USER[$f]} 
			$SYSCTL -w dev.oprofile.$f.unit_mask=${CTR_UM[$f]} 
			$SYSCTL -w dev.oprofile.$f.event=${CTR_EVENT_VAL[$f]}
		fi
		f=$(($f+1))
	done
}
 
# start the daemon
do_start() {
	OPD_ARGS="--buffer-size=$BUF_SIZE --ignore-myself=$IGNORE_MYSELF \
		--log-file=$LOG_FILE --base-dir=$DIR --samples-dir=$SAMPLES_DIR \
		--device-file=$DEVICE_FILE --note-device-file=$NOTE_DEVICE_FILE \
		--kernel-only=$KERNEL_ONLY \
		--hash-map-device-file=$HASH_MAP_DEVICE_FILE --vmlinux=$VMLINUX \
		--map-file=$MAP_FILE"

	if [ "$VERBOSE" = "1" ]; then
		OPD_ARGS="$OPD_ARGS --verbose"
	fi

	cpu_speed=`grep "cpu MHz" /proc/cpuinfo | tail -1 | awk -F": " '{print $2}'`
	OPD_ARGS="$OPD_ARGS --cpu-speed=$cpu_speed"

	vecho "cpu speed (estimation) : $cpu_speed"

	vecho "executing oprofiled $OPD_ARGS"
	oprofiled $OPD_ARGS
	sleep 4
	PID=`ps x | grep oprofiled | grep -v grep | awk '{print $1}'`
	if [ "$PID" = "" ]; then
		echo "Couldn't start oprofiled." >&2
		echo "Check the log file \"$LOG_FILE\" and /var/log/messages" >&2
		exit 1
	fi

	echo "Daemon started. Remember you may need to use op_dump"
	echo "to retrieve profile data"
}
 
# main

if [ "$UID" != "0" ]; then
	echo "Must be root to start oprofile." >&2
	exit 1
fi
 
do_init
do_options $@
do_stop
do_setup
do_sysctl_setup
do_start
