#!/bin/sh
# $Id$
# COPYRIGHT (C) 2000 THE VICTORIA UNIVERSITY OF MANCHESTER and John Levon
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place - Suite 330, Boston, MA 02111-1307, USA.
#

# quick and ugly interface
# op_start --help and op_start --list-events have info

SYSCTL=do_sysctl

BUF_SIZE=262144
HASH_SIZE=65536
CTR0_EVENT=
CTR1_EVENT=
KERNEL_ONLY=0
CTR0_UM=0
CTR1_UM=0
CTR0_COUNT=600000
CTR1_COUNT=600000
CTR0_USER=1
CTR0_KERNEL=1
CTR1_USER=1
CTR1_KERNEL=1
USE_PII=0
IGNORE_MYSELF=0
DIR="/var/opd"
MAP_FILE=
VMLINUX=
PID_FILTER=0
PGRP_FILTER=0
VERBOSE=0

# FIXME: needs to be generalised for more counters (e.g. athlon) 

do_help() { 
echo 'op_start: usage:
Module options
  --buffer-size=num            number of samples in kernel buffer
  --hash-table-size=num        number of entries in kernel hash table
  --kernel-only=[0|1]          profile only the kernel
  --ctr0-event=name            symbolic event name for ctr0
  --ctr1-event=name            symbolic event name for ctr1
  --ctr0-count=val             number of events between samples for ctr0
  --ctr1-count=val             number of events between samples for ctr1
  --ctr0-unit-mask=val         unit mask for ctr0
  --ctr1-unit-mask=val         unit mask for ctr1
  --ctr0-kernel=[0|1]          whether to count kernel events for ctr 0
  --ctr0-user=[0|1]            whether to count user events for ctr 0
  --ctr1-kernel=[0|1]          whether to count kernel events for ctr 1
  --ctr1-user=[0|1]            whether to count user events for ctr1
  --pid-filter=pid             Only profile process pid (if compiled in)
  --pgrp-filter=pgrp           Only profile process group pgrp (if compiled in)

Daemon options
  --use-cpu=[0|1|2]            0 or PPro, 1 for PII, 2 for PIII
  --ignore-myself=[0|1]        ignore samples for oprofiled
  --log-file=file              log file
  --base-dir=dir               base directory of daemon
  --samples-dir=file           output samples directory
  --device-file=file           profile device file
  --hash-map-device-file=file  profile hash map device file
  --map-file=file              System.map for running kernel file
  --vmlinux=file               vmlinux kernel image
  --verbose                    be verbose in the daemon log

General options
  --list-events                list event types and unit masks
  --help                       this message'
}

# utilities functions.

#  A replacement function for the sysctl (procps package) utility which is
# missing on some distribution (e.g. slack 7.0). 
#  Handle only the -w option of sysctl.
do_sysctl()
{
	if [ x$1 != x"-w" ]; then
		echo "$0 unknown option"
		exit 1
	fi

	shift

	arg=`echo $1 | awk -F= '{print $1}'`
	val=`echo $1 | awk -F= '{print $2}'`

	dev_name=`echo $arg | tr . /`

	if [ ! -f /proc/sys/$dev_name ]; then
		echo "/proc/sys/$dev_name does not exist or is not a regular file"
		exit 1
	fi

	echo $val > /proc/sys/$dev_name
}

LOG_FILE=
SAMPLES_DIR=
DEVICE_FILE=

# get specified options

while [ "$#" -ne 0 ]
do
	arg=`echo $1 | awk -F= '{print $1}'`
	val=`echo $1 | awk -F= '{print $2}'`
	case "$arg" in
		--use-cpu)
			if [ "$val" != "" ]; then
				USE_PII=$val
			else
				USE_PII=1
			fi
			;;
		--ignore-myself)
			if [ "$val" != "" ]; then
				IGNORE_MYSELF=$val
			else
				IGNORE_MYSELF=1
			fi
			;;
		--buffer-size)
			BUF_SIZE=$val
			;;
		--hash-table-size)
			HASH_SIZE=$val
			;;
		--kernel-only)
			if [ "$val" != "" ]; then
				KERNEL_ONLY=$val
			else
				KERNEL_ONLY=1
			fi
			;;
		--ctr0-unit-mask)
			CTR0_UM=$val
			;;
		--ctr1-unit-mask)
			CTR1_UM=$val
			;;
		--ctr0-event)
			CTR0_EVENT=$val
			;;
		--ctr1-event)
			CTR1_EVENT=$val
			;;
		--ctr0-count)
			CTR0_COUNT=$val
			;;
		--ctr1-count)
			CTR1_COUNT=$val
			;;
		--ctr0-user)
			CTR0_USER=$val
			;;
		--ctr0-kernel)
			CTR0_KERNEL=$val
			;;
		--ctr1-user)
			CTR1_USER=$val
			;;
		--ctr1-kernel)
			CTR1_KERNEL=$val
			;;
		--base-dir)
			DIR=$val
			;;
		--samples-dir)
			SAMPLES_DIR=$val
			;;
		--log-file)
			LOG_FILE=$val
			;;
		--device-file)
			DEVICE_FILE=$val
			;;
		--hash-map-device-file)
			HASH_MAP_DEVICE_FILE=$val
			;;
		--map-file)
			MAP_FILE=$val
			;;
		--vmlinux)
			VMLINUX=$val
			;;
		--pid-filter)
			PID_FILTER=$val
			;;
		--pgrp-filter)
			PGRP_FILTER=$val
			;;
		--verbose)
			VERBOSE=1
			;;
		--help)
			do_help
			exit 0
			;;

		--list-events)
			exec op_help
			;;
		*)
			echo "Unknown option \"$arg\". See op_start --help"
			exit 1
			;; 
	esac
	shift
done

if [ -z "$CTR0_EVENT" -a -z "$CTR1_EVENT" ]; then
	echo "You haven't specified what events you would like to count, e.g."
	echo "op_start ... --ctr0-event=CPU_CLK_UNHALTED --ctr0-count=600000"
	echo "Enter op_start --help for full options"
	exit 1
fi
 
 
CTR0_EVENT_VAL=
if [ ! -z "$CTR0_EVENT" ]; then
	CTR0_EVENT_VAL=`op_help $CTR0_EVENT`
fi
 
CTR1_EVENT_VAL=
if [ ! -z "$CTR1_EVENT" ]; then
	CTR1_EVENT_VAL=`op_help $CTR1_EVENT`
fi

if [ -z "$CTR0_EVENT_VAL" -a ! -z "$CTR0_EVENT" ]; then
	echo "Unknown event \"$CTR0_EVENT\""
	exit 1
fi

if [ -z "$CTR1_EVENT_VAL" -a ! -z "$CTR1_EVENT" ]; then
	echo "Unknown event \"$CTR1_EVENT\""
	exit 1
fi

# stop any existing daemon

op_stop >/dev/null

grep oprof /proc/devices >/dev/null
if [ "$?" -ne 0 ]; then
	modprobe oprofile
	if [ "$?" != "0" ]
	then
		echo "Couldn't load oprofile.o module"
		exit 1
	fi
	grep oprofile /proc/modules >/dev/null
	if [ "$?" != "0" ]
	then
		echo "Couldn't load oprofile.o module"
		exit 1
	fi
fi

if [ ! -d "$DIR" ]; then
       mkdir -p "$DIR"
       if [ "$?" != "0" ]
       then
               echo "Couldn't mkdir -p $DIR"
               exit 1
       fi
       chmod 755 "$DIR"
fi

if [ "$LOG_FILE" = "" ]; then
	LOG_FILE="$DIR/oprofiled.log"
fi
if [ "$SAMPLES_DIR" = "" ]; then
	SAMPLES_DIR="$DIR/samples/"
fi
if [ "$DEVICE_FILE" = "" ]; then
	DEVICE_FILE="$DIR/opdev"
fi
if [ "$HASH_MAP_DEVICE_FILE" = "" ]; then
	HASH_MAP_DEVICE_FILE="$DIR/ophashmapdev"
fi

if [ "$VERBOSE" = "1" ]; then 
  echo "Parameters used:"
  echo "BUF_SIZE $BUF_SIZE"
  echo "HASH_SIZE $HASH_SIZE"
  echo "CTR0_EVENT $CTR0_EVENT"
  echo "CTR1_EVENT $CTR1_EVENT"
  echo "CTR0_UM $CTR0_UM"
  echo "CTR1_UM $CTR1_UM"
  echo "CTR0_COUNT $CTR0_COUNT"
  echo "CTR1_COUNT $CTR1_COUNT"
  echo "CTR0_OSUSR $CTR0_OSUSR"
  echo "CTR1_OSUSR $CTR1_OSUSR"
  echo "USE_PII $USE_PII"
  echo "IGNORE_MYSELF $IGNORE_MYSELF"
  echo "DIR $DIR"
  echo "LOG_FILE $LOG_FILE"
  echo "SAMPLES_DIR $SAMPLES_DIR"
  echo "DEVICE_FILE $DEVICE_FILE"
  echo "MAP_FILE $MAP_FILE"
  echo "VMLINUX $VMLINUX"
fi

>$LOG_FILE

if [ -z "$MAP_FILE" ]; then
	echo "No map file specified. You must specify the correct System.map and vmlinux files, e.g."
	echo "op_start --map-file=/path/to/System.map --vmlinux=/path/to/vmlinux"
	echo "Enter op_start --help for full options"
	exit 1
fi

if [ -z "$VMLINUX" ]; then
	echo "No vmlinux file specified. You must specify the correct System.map and vmlinux files, e.g."
	echo "op_start --map-file=/path/to/System.map --vmlinux=/path/to/vmlinux"
	echo "Enter op_start --help for full options"
	exit 1
fi

if [ ! -f "$MAP_FILE" ]; then
	echo "The specified map file \"$MAP_FILE\" doesn't exist."
	exit 1
fi

if [ ! -f "$MAP_FILE" ]; then
	echo "The specified map file \"$MAP_FILE\" doesn't exist."
	exit 1
fi

if [ -c "$DEVICE_FILE" ]; then
	if [ "$VERBOSE" = "1" ]; then 
	echo "Removing $DEVICE_FILE"
	fi 
	rm "$DEVICE_FILE"
fi

if [ -c "$HASH_MAP_DEVICE_FILE" ]; then
	if [ "$VERBOSE" = "1" ]; then 
	echo "Removing $HASH_MAP_DEVICE_FILE"
	fi 
	rm "$HASH_MAP_DEVICE_FILE"
fi

if [ ! -d "$SAMPLES_DIR" ]; then
	mkdir -p "$SAMPLES_DIR"
	if [ "$?" != "0" ]
	then
		echo "Couldn't mkdir -p $SAMPLES_DIR"
		exit 1
	fi
	chmod 755 "$SAMPLES_DIR"
fi

MAJOR_NR=`grep oprof /proc/devices | awk '{print $1}'`

if [ "$VERBOSE" = "1" ]; then 
echo "Doing mknod $DEVICE_FILE"
fi 
mknod "$DEVICE_FILE" c $MAJOR_NR 0
if [ "$?" != "0" ]
then
	echo "Couldn't mknod $DEVICE_FILE"
	exit 1
fi
chmod 700 "$DEVICE_FILE"
 
if [ "$VERBOSE" = "1" ]; then 
echo "Doing mknod $HASH_MAP_DEVICE_FILE"
fi
mknod "$HASH_MAP_DEVICE_FILE" c $MAJOR_NR 1
if [ "$?" != "0" ]
then
	echo "Couldn't mknod $HASH_MAP_DEVICE_FILE"
	exit 1
fi
chmod 700 "$HASH_MAP_DEVICE_FILE"

# Necessary in this case :
# op_start ctr0-on ctr1-on
# op_start ctr0-on
$SYSCTL -w dev.oprofile.0.enabled=0 >/dev/null
$SYSCTL -w dev.oprofile.1.enabled=0 >/dev/null
$SYSCTL -w dev.oprofile.0.event=0 >/dev/null
$SYSCTL -w dev.oprofile.1.event=0 >/dev/null

$SYSCTL -w dev.oprofile.hashsize=$HASH_SIZE >/dev/null
$SYSCTL -w dev.oprofile.bufsize=$BUF_SIZE >/dev/null
$SYSCTL -w dev.oprofile.kernel_only=$KERNEL_ONLY >/dev/null
$SYSCTL -w dev.oprofile.pid_filter=$PID_FILTER >/dev/null
$SYSCTL -w dev.oprofile.pgrp_filter=$PGRP_FILTER >/dev/null

# FIXME do something for all CPUs 
if [ "$CTR0_EVENT" != "" ]; then
	$SYSCTL -w dev.oprofile.0.enabled=1 >/dev/null
	$SYSCTL -w dev.oprofile.0.count=$CTR0_COUNT >/dev/null
	$SYSCTL -w dev.oprofile.0.kernel=$CTR0_KERNEL >/dev/null
	$SYSCTL -w dev.oprofile.0.user=$CTR0_USER >/dev/null
	$SYSCTL -w dev.oprofile.0.unit_mask=$CTR0_UM >/dev/null
	$SYSCTL -w dev.oprofile.0.event=$CTR0_EVENT_VAL >/dev/null
fi
if [ "$CTR1_EVENT" != "" ]; then
	$SYSCTL -w dev.oprofile.1.enabled=1 >/dev/null
	$SYSCTL -w dev.oprofile.1.count=$CTR1_COUNT >/dev/null
	$SYSCTL -w dev.oprofile.1.kernel=$CTR1_KERNEL >/dev/null
	$SYSCTL -w dev.oprofile.1.user=$CTR1_USER >/dev/null
	$SYSCTL -w dev.oprofile.1.unit_mask=$CTR1_UM >/dev/null
	$SYSCTL -w dev.oprofile.1.event=$CTR1_EVENT_VAL >/dev/null
fi
 
OPD_ARGS="--buffer-size=$BUF_SIZE --use-cpu=$USE_PII --ignore-myself=$IGNORE_MYSELF \
	--log-file=$LOG_FILE --base-dir=$DIR --samples-dir=$SAMPLES_DIR \
	--device-file=$DEVICE_FILE --kernel-only=$KERNEL_ONLY \
	--hash-map-device-file=$HASH_MAP_DEVICE_FILE --vmlinux=$VMLINUX"

if [ "$MAP_FILE" != "" ]; then
	OPD_ARGS="$OPD_ARGS --map-file=$MAP_FILE"
fi

if [ "$VERBOSE" = "1" ]; then
	OPD_ARGS="$OPD_ARGS --verbose"
fi

cpu_speed=`grep "cpu MHz" /proc/cpuinfo | tail -1 | awk -F": " '{print $2}'`
OPD_ARGS="$OPD_ARGS --cpu-speed=$cpu_speed"

if [ "$VERBOSE" = "1" ]; then
	echo "cpu speed (estimation) : $cpu_speed"
fi

oprofiled $OPD_ARGS
sleep 4
PID=`ps x | grep oprofiled | grep -v grep | awk '{print $1}'`
if [ "$PID" = "" ]
then
	echo "Couldn't start oprofiled."
	echo "Check the log file \"$LOG_FILE\" and /var/log/messages"
	exit 1
fi

echo "Daemon started. Remember you may need to"
echo "echo 1 >/proc/sys/dev/oprofile/dump"
echo "to get profiling data ..."
