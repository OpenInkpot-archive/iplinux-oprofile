
The number of interrupts delivered per 5-second intervals was counted, whilst compiling a kernel
with make -j3 MAKE="make -j3" on the test machine.

Kernel: 2.4.0ac9 no-hlt option
Oprofile: 0.0.3cvs

Total interrupt count over 5 * 86 seconds : 2627881
Average interrupts per second : 6111.4
 
The profiler was configured with CPU_CLK_UNHALTED, 100000 interval. Given the CPU MHz of 601MHz,
we would in fact expect around this number of interrupts. This shows that on a busy machine,
a simple calculation like this can be a rough guide to the grain of the profiling.

However, there is a wide variation in the data. The "no-hlt" option was used to discount the possibility
of halts in the kernel's idle routine skewing the counts. 

The measurement below is not very accurate, as jiffies is only updated every timer interrupt. This however
shouldn't cause the wide variation seen.

The CPU could be idle waiting on memory, functional unit, or something. 

This *doesn't* explain why an idle system has practically no interrupts generated though.

Maybe the cpu_idle() busy loop is somehow being translated into a halted CPU anyway, despite the lack of
explicit hlt() (i.e. perhaps it's a microcode thing). 

Ideas on a postcard please.

Raw data
--------

86 interrupt counts, each representing five seconds

16182 20065 13844 4045 16285 20661 19588 23420 30299 35377 35377 35383 35375 35389 35385 35374 35382 35167 35381 35378 35387 35384
35391 35401 35398 35402 35381 35384 35400 35185 35387 35388 35396 35405 35411 35433 35413 35361 35363 35376 35407 35423 35170 35054
33021 35402 35406 35374 35370 26835 24272 20652 15018 19329 17595 20127 19625 15733 21967 21764 18849 32103 33927 16361 7376 35369
35385 35127 35349 35345 35374 35322 35333 35347 35357 35343 35311 35354 35319 35333 35155 35350 35363 35363 35330 13189

Patch used
----------

Index: oprofile.c
===================================================================
RCS file: /home/moz/cvs/oprofile/oprofile.c,v
retrieving revision 1.49
diff -u -p -r1.49 oprofile.c
--- oprofile.c	2001/01/21 01:11:55	1.49
+++ oprofile.c	2001/01/21 02:08:18
@@ -60,6 +60,9 @@ static struct _oprof_data oprof_data[NR_
 
 extern spinlock_t map_lock;
 
+static int count;
+static ulong last_jif; 
+
 /* ---------------- NMI handler ------------------ */
 
 /* FIXME: this whole handler would probably be better in straight asm */
@@ -133,6 +136,12 @@ static int op_check_ctr(struct _oprof_da
 	ulong l,h;
 	get_perfctr(l,h,ctr);
 	if (ctr_overflowed(l)) {
+		count++;
+		if (((jiffies - last_jif) / HZ) > 5)  {
+			last_jif = jiffies;
+			printk("count %u.\n", count);
+			count = 0;
+		}
 		op_do_profile(data,regs,ctr);
 		return 1;
 	}
@@ -826,6 +835,7 @@ DECLARE_MUTEX(sysctlsem);
 static int oprof_start(void)
 {
 	int err = 0;
+	last_jif = jiffies; 
 	
 	down(&sysctlsem);
 
