#ifndef OPF_FILTER_H
#define OPF_FILTER_H

#include <stddef.h>
#include <iostream>
#include <string>

#include "../op_user.h"

// Add run-time checking if true.
static const bool sanity_check = true;

//---------------------------------------------------------------------------
// A simple container of counter.
class counter_array_t {
 public:
	counter_array_t();

	size_t operator[](size_t index) const {
		return value[index];
	}

	// This can be avoided if counter_array_t have a build_from_string
	// member function.
	size_t & operator[](size_t index) {
		return value[index];
	}

	counter_array_t & operator+=(const counter_array_t &);

 private:
	// for now we avoid dyn alloc here by allowing OP_MAX_COUNTERS rather
	// than op_nr_counters. This is probably the bad way if the number of
	// counters available becomes great.
	size_t value[OP_MAX_COUNTERS];
};

//---------------------------------------------------------------------------
// A simple container for a fileno:linr location
struct file_location {
	// This rely on a ref counted string implementation for efficiency.
	string filename;	// string() if not valid.
	int linenr;             // 0 means internally generated by the compiler
};

//---------------------------------------------------------------------------
// associate vma address with (filename linenr counter[])
struct sample_entry {
	file_location file_loc;
	unsigned long vma;        // would be bfd_vma but avoid depend on bfd.h
	counter_array_t counter;

	size_t build(const string& str, size_t pos, bool have_linenr_info);

	void debug_dump(ostream & out) const;
};

//---------------------------------------------------------------------------
// stored as a vector<symbol_entry> sorted by increased vma.
struct symbol_entry {
	sample_entry sample;
	string name;
	// [first, last[ gives the range of symbol_entry.
	size_t first;
	size_t last;

	void debug_dump(ostream & out) const;
};

//---------------------------------------------------------------------------

class symbol_container_impl;

class symbol_container_t {
 public:
	 symbol_container_t();
	~symbol_container_t();

	size_t size() const;

	const symbol_entry & operator[](size_t index) const;
	      symbol_entry & operator[](size_t index);

	void push_back(const symbol_entry &);

	const symbol_entry * find(string filename, size_t linenr) const;

	void flush_input_symbol();

	const symbol_entry * find_by_vma(unsigned long vma) const;

	// get a vector of symbols sorted by increased count.
	void get_symbols_by_count(size_t counter, vector<const symbol_entry*>& v) const;
 private:
	symbol_container_impl * impl;
};

//---------------------------------------------------------------------------

class sample_container_impl;

class sample_container_t {
 public:
	sample_container_t();
	~sample_container_t();

	size_t size() const;

	const sample_entry & operator[](size_t index) const;

	bool accumulate_samples_for_file(counter_array_t & counter, 
					 const string & filename) const;

	const sample_entry * find_by_vma(unsigned long vma) const;

	bool accumulate_samples(counter_array_t &, const string & filename, 
				size_t linenr) const;

	void flush_input_counter();

	void push_back(const sample_entry &);
 private:
	sample_container_impl * impl;
};

#endif /* !OPF_FILTER_H */
