#ifndef OP_FILTER_H
#define OP_FILTER_H

#include <stddef.h>
#include <iostream>
#include <string>

// The maximum number of counter. Would be a parameter coming from configure.
static const size_t max_counter_number = 2;

//
// I don't like 
// #ifdef TEST ... code ... #endif features I use rather
// if (sanity_check)  { ... code  ... } and I rely on the dead code
// elimination's algotithm of compilers for efficiency.
//
static const bool sanity_check = true;

//---------------------------------------------------------------------------
// Forward declaration.

//---------------------------------------------------------------------------
// A simple container of counter to give independancy on the number of hardware counter.
class counter_array_t {
 public:
	counter_array_t();

	size_t operator[](size_t index) const {
		return value[index];
	}

	// This can be avoided if counter_array_t have a build_from_string
	// member function.
	size_t & operator[](size_t index) {
		return value[index];
	}

	counter_array_t & operator+=(const counter_array_t &);

 private:
	size_t value[max_counter_number];
};

//---------------------------------------------------------------------------
// A simple container for a fileno:linr location
struct file_location {
	// This rely on a ref counted string implementation for efficiency.
	string filename;          // string() if not valid.
	int linenr;               // 0 means internally generated by the compiler.
};

//---------------------------------------------------------------------------
// associate vma address with (filename linenr counter[])
// The public derivation do not express an Is-A relation.
struct sample_entry : public file_location {
	unsigned long vma;        // would be bfd_vma but avoid depend on bfd.h
	counter_array_t counter;

	size_t build(string str, size_t pos, bool have_linenr_info);

	void debug_dump(ostream & out) const;
};

//---------------------------------------------------------------------------
// stored as a vector<symbol_entry> sorted by increased vma.
// The public derivation do not express an Is-A relation
struct symbol_entry : public sample_entry {
	string name;
	// [first, last[ index inside the vector<sample_entry>
	size_t first;
	size_t last;

	void debug_dump(ostream & out) const;
};

//---------------------------------------------------------------------------

class symbol_container_impl;

class symbol_container_t {
 public:
	 symbol_container_t();
	~symbol_container_t();

	size_t size() const;

	const symbol_entry & operator[](size_t index) const;
	      symbol_entry & operator[](size_t index);

	void push_back(const symbol_entry &);

	const symbol_entry * find(string filename, size_t linenr) const;

	void flush_input_symbol();

	const symbol_entry * find_by_vma(unsigned long vma) const;
 private:
	symbol_container_impl * impl;
};

//---------------------------------------------------------------------------

class sample_container_impl;

class sample_container_t {
 public:
	sample_container_t();
	~sample_container_t();

	size_t size() const;

	const sample_entry & operator[](size_t index) const;

	bool cumulate_samples_for_file(counter_array_t & counter, 
				       const string & filename) const;

	const sample_entry * find_by_vma(unsigned long vma) const;

	bool cumulate_samples(counter_array_t &, const string & filename, 
			      size_t linenr) const;

	void flush_input_counter();

	void push_back(const sample_entry &);
 private:
	sample_container_impl * impl;
};

#endif /* !OP_FILTER_H */
