<HTML
><HEAD
><TITLE
>Usage</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="OProfile manual"
HREF="oprofile-guide.html"><LINK
REL="PREVIOUS"
TITLE="Installation"
HREF="install.html"><LINK
REL="NEXT"
TITLE="Starting profiling"
HREF="starting-daemon.html"></HEAD
><BODY
CLASS="CHAPTER"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>OProfile manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="install.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="starting-daemon.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="USAGE"
>Chapter 2. Usage</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="usage.html#TYPICAL"
>A typical session</A
></DT
><DT
><A
HREF="starting-daemon.html"
>Starting profiling</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TYPICAL"
>A typical session</A
></H1
><P
>Before getting into detail about usage, it's probably a good idea to have a quick stroll through an example
session.</P
><P
> 
First we need to start the profiler running in the background. We need to pass the correct <TT
CLASS="FILENAME"
>System.map</TT
> 
and <TT
CLASS="FILENAME"
>vmlinux</TT
> files to the daemon, and we need to specify what event to count and the counter value.
Here I've started with :</P
><P
><B
CLASS="COMMAND"
>op_start --map-file=/boot/2.4.0ac12/System.map --vmlinux=/boot/2.4.0ac12/vmlinux  --ctr0-event=CPU_CLK_UNHALTED --ctr0-count=600000</B
></P
><P
>A quick <B
CLASS="COMMAND"
>ps ax</B
> confirms that the daemon (<B
CLASS="COMMAND"
>oprofiled</B
>) has started, 
along with the kernel thread (<B
CLASS="COMMAND"
>oprof-thread</B
>). Data is now being collected in the kernel.
Now we can do whatever we like ... although in this case I'm profiling the C++ application 
<A
HREF="http://www.lyx.org/"
TARGET="_top"
>LyX</A
>, previously compiled using the <TT
CLASS="OPTION"
>-g</TT
> option to <B
CLASS="COMMAND"
>g++</B
>.
Note that unlike <B
CLASS="COMMAND"
>gprof</B
>, no instrumentation (<TT
CLASS="OPTION"
>-pg</TT
> and <TT
CLASS="OPTION"
>-a</TT
> options to <B
CLASS="COMMAND"
>gcc</B
>)
is necessary. This is major factor in achieving the low overhead of OProfile. </P
><P
>Anyway, data will be processed by daemon every ten minutes. I'm too lazy to wait that long, so force the issue with :</P
><P
><B
CLASS="COMMAND"
>echo 1 &#62;/proc/sys/dev/oprofile/dump</B
></P
><P
> 
which will ask the kernel module to dump as much data as it can to the daemon.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Forcing a dump like this can cause the daemon to become very busy, especially the first time it is done. Don't worry,
that's not normal behaviour; so if you are profiling over a larger period of time, such spikes won't appear. </P
></BLOCKQUOTE
></DIV
> 

I can now ask for a symbol-based summary of the sample profile :</P
><P
><B
CLASS="COMMAND"
>oprofpp --demangle -l /home/moz/lyx/lyx-devel/src/lyx &#62;oprof.out</B
></P
><P
>You will have to specify the full path unless you also specify the sample file (see the manpage). This can be quite slow
on large binaries, so sit tight. As it's a C++ program, I asked for the symbols to be demangled to a readable form. Examining
the file will give the symbols against which the most hits were registered. In this case I got :</P
><P
><TT
CLASS="COMPUTEROUTPUT"
><P
CLASS="LITERALLAYOUT"
>&nbsp;<br>
...<br>
Row::par(void)[0x0813ab54]:&nbsp;5.4079%&nbsp;(472&nbsp;samples)<br>
LyXText::GetRow(LyXParagraph&nbsp;*,&nbsp;int,&nbsp;int&nbsp;&#38;)&nbsp;const[0x08170a4c]:&nbsp;5.5683%&nbsp;(486&nbsp;samples)<br>
LyXParagraph::GetFontSettings(BufferParams&nbsp;const&nbsp;&#38;,&nbsp;int)&nbsp;const[0x08145420]:&nbsp;5.7516%&nbsp;(502&nbsp;samples)<br>
Row::next(void)&nbsp;const[0x0813ac24]:&nbsp;15.4904%&nbsp;(1352&nbsp;samples)</P
></TT
></P
><P
>at the top. Note that over a longer run (or with a lower ctr0-count value) the number of samples will be much more statistically
reliable. Note that these sample counts do <I
CLASS="EMPHASIS"
>not</I
> necessarily reflect the relative amounts of time
spent in each function - it depends on the event being counted. In this case we used <TT
CLASS="CONSTANT"
>CPU_CLK_UNHALTED</TT
>
which the command <B
CLASS="COMMAND"
>op_help</B
> tells us is "clocks processor is not halted", so in fact is likely to represent
the relative time spent accurately (in fact, experiments have shown that using this event is far more accurate than the values
produced by <B
CLASS="COMMAND"
>gprof</B
>).
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>If you're more used to <B
CLASS="COMMAND"
>gprof</B
> style profile output, you can use <B
CLASS="COMMAND"
>oprofpp -g gmon.out</B
> and then
<B
CLASS="COMMAND"
>gprof -p binary</B
> to get flat profiles. OProfile does not (cannot) support the call graph
feature of <B
CLASS="COMMAND"
>gprof</B
>. </P
></BLOCKQUOTE
></DIV
> </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="install.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="oprofile-guide.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="starting-daemon.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Installation</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Starting profiling</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>